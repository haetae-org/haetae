import { Callout } from 'nextra-theme-docs'
import PkgManagerTabs from '../components/PkgManagerTabs'
import TokenLinkCode from '../components/TokenLinkCode'

# Getting Started

It's simple and flexible.<br/>
You can easily use it both for a new project or an existing project.<br/>
It works well with monorepo as well.


## How to test incrementally?

Let's say you're building a calculator project, named *'my-calculator'*.

```fish
my-calculator
â”œâ”€â”€ package.json
â”œâ”€â”€ src
â”‚Â Â  â”œâ”€â”€ add.js
â”‚Â Â  â”œâ”€â”€ exponent.js
â”‚Â Â  â”œâ”€â”€ multiply.js
â”‚Â Â  â””â”€â”€ subtract.js
â””â”€â”€ test
    â”œâ”€â”€ add.test.js
    â”œâ”€â”€ exponent.test.js
    â”œâ”€â”€ multiply.test.js
    â””â”€â”€ subtract.test.js
```

Dependency graph is like this:

<img src="/getting-started/dependency-graph.svg" alt="Dependeny graph of 'my-calculator'"/>

*`exponent.js`* depends on *`multiply.js`*, which depends on *`add.js`* and so on.

When testing, we should take the dependency graph into account.<br/>
We do NOT have to test all files (*`*.test.js`*) for every single tiny change. <small>(Waste of your CI resources and time)</small><br/>
Rather, **we should do it incrementally, which means testing only files affected by the changes.**

For example, when *`multiply.js`* is changed, test only *`exponent.test.js`* and *`multiply.test.js`*.<br/>
When *`add.js`* is changed, test all files (<small>*`exponent.test.js`*, *`multiply.test.js`*, *`subtract.test.js`* and *`add.test.js`*</small>).<br/>
When test file <small>(e.g. *`add.test.js`*)</small> is changed, then just only execute the test file itself <small>(e.g. *`add.test.js`*)</small>.

Nothing more, nothing less.

Then how can we do it?<br/>
Here is where **Haetae** comes in.<br/>
By just a simple config, Haetae can automatically detect the dependency graph and test only affected files.

### Installation

So, let's install Haetae. (<small>Node 16 or higher is required.</small>)<br/>
It doesn't matter whether your project is new or existing <small>(Haetae can be incrementally adapted)</small>.<br/>
It's so good for monorepo as well. <small>(Guided later in other part of docs.)</small><br/>
Literally **any project** is proper.

<br/>

<PkgManagerTabs>
```bash
npm install --save-dev haetae
```
```bash
yarn add --dev haetae
```
```bash
pnpm add --save-dev haetae
```
</PkgManagerTabs>

<Callout>
  **Are you developing a library (e.g. plugin) for Haetae?** <br/>
  You can depend on [`@haetae/core{:ts}`](apis/haetae-core), [`@haetae/utils{:ts}`](apis/haetae-utils),
  [`@haetae/git{:ts}`](apis/haetae-git), [`@haetae/javascript{:ts}`](apis/haetae-javascript),
  [`@haetae/cli{:ts}`](apis/haetae-cli) independently. Note that the package [`haetae{:ts}`](apis/haetae)
  include all of them.
</Callout>

### Basic configuration for incremental testing

Now, we are ready to configure Haetae.<br/>
Let's create a config file *`haetae.config.js`*.<br/>

```fish
my-calculator
â”œâ”€â”€ haetae.config.js # <--- Haetae config file
â”œâ”€â”€ package.json
â”œâ”€â”€ src # contents are omitted for brevity
â””â”€â”€ test # contents are omitted for brevity
```

<Callout>
  **Typescript Support** <br/>
  If you use typescript, it can be *`haetae.config.ts`*.
  Then install [`ts-node`](https://www.npmjs.com/package/ts-node) as `peerDependencies`.
  You need `ts-node` no matter if you actually use it directly or not.
  The `peerDependencies` is marked as optional, which means non-typescript users don't have to install it.
</Callout>

<Callout>
  **CJS/ESM** <br/>
  Haetae supports both CJS and ESM project. <br/>
  Haetae is written in ESM, but it can be used in CJS projects as well, as long as the config file is ESM.
  If your project is CJS, name the config file *`haetae.config.mjs`* or *`haetae.config.mts`*.
  If your project is ESM, name the config file *`haetae.config.js`* or *`haetae.config.ts`*.
</Callout>

We can write it down like this.<br/>
Make sure you initialized git. Haetae can be used with any other version control systems, but using git is assumed in this article.

<TokenLinkCode tokens={{
  'configure': './apis/haetae#configure',
  '.changedFiles': './apis/haetae-git#changedfiles',
  '.glob': './apis/haetae-utils#glob',
  '.dependsOn': './apis/haetae-js#dependsOn',
  '.exec': './apis/haetae-utils#exec',
}}>
```js filename="haetae.config.js"
import { configure, git, utils, js } from 'haetae'

export default configure({
  // Other options are ommitted for brevity.
  commands: {
    myTest: {
      run: async () => {
        const changedFiles = await git.changedFiles()
        const testFiles = await utils.glob(['**/*.test.js'])
        // An array of test files which (transitively) depend on changed files
        const affectedTestFiles = testFiles.filter((testFile) =>
          js.dependsOn({
            dependent: testFile,
            dependencies: changedFiles,
          })
        )

        if (affectedTestFiles.length > 0) {
          // Equals to "pnpm jest /path/to/foo.test.ts /path/to/bar.test.ts ..."
          // Change 'pnpm' and 'jest' to your package manager and test runner.
          await utils.exec(`pnpm jest ${affectedTestFiles.join(' ')}`)
        }
      },
    },
  },
})
```
</TokenLinkCode>

Multiple APIs are used in the config file above.<br/>
They all have various options <small>(Check out API docs)</small>.
But we are going to use their sensible defaults in this article.<br/>
I will explain the code above in detail later.<br/>
For now, just change the command `pnpm jest` in `utils.exec(){:ts}` to your package manager and test runner.<br/>
And let's run `haetae` CLI below.

```bash
$ haetae myTest
```
<small>(Unless you installed `haetae` globally, you should execute it through package manager (e.g. `pnpm haetae myTest`))</small>

Note that `myTest` in the command above is the name of the command we defined in the config file.<br/>
It will print the result like this.

```bash filename="terminal"
âœ”  success   Command myTest is successfully executed.

âŽ¡ ðŸ•— time: 2023 May 28 11:06:06 (timestamp: 1685239566483)
âŽœ ðŸŒ± env: {}
âŽœ ðŸ’¾ data:
âŽœ      "@haetae/git":
âŽœ        commit: 979f3c6bcafe9f0b81611139823382d615f415fd
âŽœ        branch: main
âŽ£        pkgVersion: 0.0.12
```

As this is the first time of running the command `haetae myTest`, `git.changedFiles(){:ts}` in the config returns every file as changed files.
This behavior results in running all of the tests.<br/>

May you have noticed, the store file *`.haetae/store.json`* is generated.
It stores history of Haetae executions, which makes incremental tasks possible.
For example, the commit ID `979f3c6` above is the current git HEAD `haetae myTest` ran on,
and this information is logged in the store file to be used later.

```fish
my-calculator
â”œâ”€â”€ .haetae/store.json # <--- Generated
â”œâ”€â”€ haetae.config.js
â”œâ”€â”€ package.json
â”œâ”€â”€ src
â””â”€â”€ test
```

### Detecting the last commit Haetae ran on successfully

Let's say we made some changes and added 2 commits.

<img src="/getting-started/commit-history.svg" alt="Commit history after the first running of Haetae"/>

`979f3c6` is the last commit Haetae ran on successfully.<br/>
What will happen when we run Haetae again?

```bash
$ haetae myTest
```

This time, only *`exponent.test.js`* and *`multiply.test.js`* are executed.<br/>
That's because `git.changedFiles(){:ts}` returns only the files changed since the last successful execution of Haetae.<br/>

```bash filename="terminal"
âœ”  success   Command myTest is successfully executed.

âŽ¡ ðŸ•— time: 2023 May 28 19:03:25 (timestamp: 1685268205443)
âŽœ ðŸŒ± env: {}
âŽœ ðŸ’¾ data:
âŽœ      "@haetae/git":
âŽœ        commit: 1d17a2f2d75e2ac94f31e53376c549751dca85fb
âŽœ        branch: main
âŽ£        pkgVersion: 0.0.12
```

Accordingly, the new commit `1d17a2f` is logged in the store file.<br/>

The output above is an example of successful task.
Conversely, if the test fails, `utils.exec(){:ts}` in the config throws an error.
So `myTest.run(){:ts}` is not completed successfully, causing the store file is not renewed.<br/>

This behavior is useful for incremental tasks.
The failed test (or any incremental task) will be re-executed later until the problem is fixed.
