import { Callout } from 'nextra-theme-docs'
import PkgManagerTabs from '../components/PkgManagerTabs'
import TokenLinkCode from '../components/TokenLinkCode'

# Getting Started

Haetae is incremental task runner.<br/>
The task can be test, lint, build, or anything.<br/>
It can be used in any project, no matter what language, framework, test runner, linter, or build system you use.<br/>
For now in this article, we are starting from an example of incremental testing.

## Incremental test

Let's say you're building a calculator project, named *'my-calculator'*.

```fish
my-calculator
â”œâ”€â”€ package.json
â”œâ”€â”€ src
â”‚Â Â  â”œâ”€â”€ add.js
â”‚Â Â  â”œâ”€â”€ exponent.js
â”‚Â Â  â”œâ”€â”€ multiply.js
â”‚Â Â  â””â”€â”€ subtract.js
â””â”€â”€ test
    â”œâ”€â”€ add.test.js
    â”œâ”€â”€ exponent.test.js
    â”œâ”€â”€ multiply.test.js
    â””â”€â”€ subtract.test.js
```

Dependency graph is like this.

<img src="/getting-started/dependency-graph.svg" alt="Dependeny graph of 'my-calculator'"/>

*`exponent.js`* depends on *`multiply.js`*, which depends on *`add.js`* and so on.

When testing, we should take the dependency graph into account.<br/>
We do NOT have to test all files (*`*.test.js`*) for every single tiny change <small>(Waste of your CI resources and time)</small>.<br/>
Rather, **we should do it incrementally, which means testing only files affected by the changes.**

For example, when *`multiply.js`* is changed, test only *`exponent.test.js`* and *`multiply.test.js`*.<br/>
When *`add.js`* is changed, test all files (<small>*`exponent.test.js`*, *`multiply.test.js`*, *`subtract.test.js`* and *`add.test.js`*</small>).<br/>
When test file <small>(e.g. *`add.test.js`*)</small> is changed, then just only execute the test file itself <small>(e.g. *`add.test.js`*)</small>.

Then how can we do it, automatically?<br/>
Here is where **Haetae** comes in.<br/>
By just a simple config, Haetae can automatically detect the dependency graph and test only affected files.<br/>
<small>(You do not have to change your test runner. In this article, [Jest](https://jestjs.io) is used just as an example.)</small>

### Installation

So, let's install Haetae. (<small>Node 16 or higher is required.</small>)<br/>
It doesn't matter whether your project is new or existing <small>(Haetae can be incrementally adapted)</small>.<br/>
It's so good for monorepo as well. <small>(Guided later in other part of docs.)</small><br/>
Literally **any project** is proper.

<br/>

<PkgManagerTabs>
```bash
npm install --save-dev haetae
```
```bash
yarn add --dev haetae
```
```bash
pnpm add --save-dev haetae
```
</PkgManagerTabs>

<Callout>
  **Are you developing a library (e.g. plugin) for Haetae?** <br/>
  You can depend on [`@haetae/core{:ts}`](apis/haetae-core), [`@haetae/utils{:ts}`](apis/haetae-utils),
  [`@haetae/git{:ts}`](apis/haetae-git), [`@haetae/javascript{:ts}`](apis/haetae-javascript),
  [`@haetae/cli{:ts}`](apis/haetae-cli) independently. Note that the package [`haetae{:ts}`](apis/haetae)
  include all of them.
</Callout>

### Basic configuration for incremental testing

Now, we are ready to configure Haetae.<br/>
Let's create a config file *`haetae.config.js`*.<br/>

```fish
my-calculator
â”œâ”€â”€ haetae.config.js # <--- Haetae config file
â”œâ”€â”€ package.json
â”œâ”€â”€ src # contents are omitted for brevity
â””â”€â”€ test # contents are omitted for brevity
```

<Callout>
  **Typescript Support** <br/>
  If you use typescript, it can be *`haetae.config.ts`*.
  Then install [`ts-node`](https://www.npmjs.com/package/ts-node) as `peerDependencies`.
  You need `ts-node` no matter if you actually use it directly or not.
  The `peerDependencies` is marked as optional, which means non-typescript users don't have to install it.
</Callout>

<Callout>
  **CJS/ESM** <br/>
  Haetae supports both CJS and ESM project. <br/>
  Haetae is written in ESM, but it can be used in CJS projects as well, as long as the config file is ESM.
  If your project is CJS, name the config file *`haetae.config.mjs`* or *`haetae.config.mts`*.
  If your project is ESM, name the config file *`haetae.config.js`* or *`haetae.config.ts`*.
</Callout>

We can write it down like this.<br/>
Make sure you initialized git. Haetae can be used with any other version control systems, but using git is assumed in this article.

<TokenLinkCode tokens={{
  'configure': './apis/haetae#configure',
  '.changedFiles': './apis/haetae-git#changedfiles',
  '.glob': './apis/haetae-utils#glob',
  '.dependsOn': './apis/haetae-javascript#dependsOn',
  '.exec': './apis/haetae-utils#exec',
}}>
```js filename="haetae.config.js"
import { configure, git, utils, js } from 'haetae'

export default configure({
  // Other options are ommitted for brevity.
  commands: {
    myTest: {
      run: async () => {
        // An array of changed files
        const changedFiles = await git.changedFiles()
        /* An array of test files.
          ['/path/to/my-calculator/exponent.test.js',
           '/path/to/my-calculator/multiply.test.js',
           '/path/to/my-calculator/subtract.test.js',
           '/path/to/my-calculator/add.test.js'] */
        const testFiles = await utils.glob(['**/*.test.js'])
        // An array of test files which (transitively) depend on changed files
        const affectedTestFiles = testFiles.filter((testFile) =>
          js.dependsOn({
            dependent: testFile,
            dependencies: changedFiles,
          })
        )

        if (affectedTestFiles.length > 0) {
          // Equals to "pnpm jest /path/to/foo.test.ts /path/to/bar.test.ts ..."
          // Change 'pnpm' and 'jest' to your package manager and test runner.
          await utils.exec(`pnpm jest ${affectedTestFiles.join(' ')}`)
        }
      },
    },
  },
})
```
</TokenLinkCode>

Multiple APIs are used in the config file above.<br/>
They all have various options <small>(Check out API docs)</small>.
But we are going to use their sensible defaults for now.<br/>
I will explain the code above in detail later.<br/>
For now, just change the command `pnpm jest` in `utils.exec(){:ts}` to your package manager and test runner.<br/>
Then run `haetae` CLI below.

```bash
$ haetae myTest
```
<small>(Unless you installed `haetae` globally, you should execute it through package manager (e.g. `pnpm haetae myTest`))</small>

Note that `myTest` in the command above is the name of the command we defined in the config file.<br/>
It will print the result like this.

```bash filename="terminal"
âœ”  success   Command myTest is successfully executed.

âŽ¡ ðŸ•— time: 2023 May 28 11:06:06 (timestamp: 1685239566483)
âŽœ ðŸŒ± env: {}
âŽœ ðŸ’¾ data:
âŽœ      "@haetae/git":
âŽœ        commit: 979f3c6bcafe9f0b81611139823382d615f415fd
âŽœ        branch: main
âŽ£        pkgVersion: 0.0.12
```

As this is the first time of running the command `haetae myTest`,
`git.changedFiles(){:ts}` in the config returns every file tracked by git in your project as changed files <small>(There are [options](./apis/haetae-git#changedfiles). Check out API docs)</small>.
This behavior results in running all of the tests.<br/>

May you have noticed, the store file *`.haetae/store.json`* is generated.
It stores history of Haetae executions, which makes incremental tasks possible.
For example, the commit ID `979f3c6` above is the current git HEAD `haetae myTest` ran on,
and this information is logged in the store file to be used later.

```fish
my-calculator
â”œâ”€â”€ .haetae/store.json # <--- Generated
â”œâ”€â”€ haetae.config.js
â”œâ”€â”€ package.json
â”œâ”€â”€ src
â””â”€â”€ test
```

### Detecting the last commit Haetae ran on successfully

Let's say we made some changes and added 2 commits.

<img src="/getting-started/commit-history.svg" alt="Commit history after the first running of Haetae"/>

`979f3c6` is the last commit Haetae ran on successfully.<br/>
What will happen when we run Haetae again?

```bash
$ haetae myTest
```

This time, only *`exponent.test.js`* and *`multiply.test.js`* are executed.<br/>
That's because `git.changedFiles(){:ts}` returns only the files changed since the last successful execution of Haetae.<br/>

```bash filename="terminal"
âœ”  success   Command myTest is successfully executed.

âŽ¡ ðŸ•— time: 2023 May 28 19:03:25 (timestamp: 1685268205443)
âŽœ ðŸŒ± env: {}
âŽœ ðŸ’¾ data:
âŽœ      "@haetae/git":
âŽœ        commit: 1d17a2f2d75e2ac94f31e53376c549751dca85fb
âŽœ        branch: main
âŽ£        pkgVersion: 0.0.12
```

Accordingly, the new commit `1d17a2f` is logged in the store file.<br/>

The output above is an example of successful task.
Conversely, if the test fails, `utils.exec(){:ts}` in the config throws an error.
So `myTest.run(){:ts}` is not completed successfully, causing the store file is not renewed.<br/>

This behavior is useful for incremental tasks.
The failed test (or any incremental task) will be re-executed later until the problem is fixed.

### Configure `env`

Sometimes we need to separate several environments.<br/>
For example, logic of your project might act differently depending on the environment variable `$NODE_ENV`.<br/>
So, the history of an incremental task also should be recorded for each environment in a separated manner.<br/>
Let's add `env` to the config file to achieve this.

<TokenLinkCode tokens={{
  'configure': './apis/haetaes#configure',
}}>
```js filename="haetae.config.js"
// Other content of the config file is ommitted for brevity.
export default configure({
  commands: {
    myTest: {
      env: { // <--- Add this
        NODE_ENV: process.env.NODE_ENV,
      },
      run: async () => { /* ... */ },
    },
  },
})
```
</TokenLinkCode>

From now on, the store file will manage the history of each environment separately.
The key name `NODE_ENV` is just an example. You can name it as you want.<br/>

You don't have to care about the past history of `myTest` executed without `env`.
When a command is configured without `env`, it's treated as if configured with `env: {}`, which is totally fine.
The past history in the store file is not automatically deleted just by the change of the config file.

Of course, you can add more keys in `env` object.<br/>
For instance, let's change the config like this.<br/>

<TokenLinkCode tokens={{
  'configure': './apis/haetaes#configure',
  '.hash': './apis/haetae-utils#hash',
  '.version': './apis/haetae-javascript#version',
  '.branch': './apis/haetae-git#branch',
}}>
```js filename="haetae.config.js"
import assert from 'node:assert/strict'
import { configure, git, utils, js } from 'haetae'

export default configure({
  commands: {
    myTest: {
      env: async () => { // <--- Changed to async function from object
        assert(['development', 'production'].includes(process.env.NODE_ENV))
        return {
          dotenvAndJestConfig: await utils.hash([
            `.env.${process.env.NODE_ENV}`,
            'jest.config.js',
          ]),
          jest: (await js.version('jest')).major,
          branch: await git.branch(),
        }
      },
      run: async () => { /* ... */ },
    },
  },
})
```
</TokenLinkCode>

The object has more keys than before, named `dotenvAndJestConfig`, `jest`, `branch`.
If any of dotenv file, jest config file, jest's major version, or git branch is changed,
it's treated as a different environment.

And now it's a function. You can even freely write any additional code in it, like assertion (`assert(){:ts}`) in the example above.
Just as like `run(){:ts}`, when an error is thrown in `env(){:ts}`,
the store file is not renewed, which is good for incremental tasks.

<Callout>
  **Hash credentials** <br/>
  `utils.hash(){:ts}` is good for credentials like a dotenv file.
  By default, it hashes by SHA-256, and you can simply change it by its [options](./apis/haetae-utils#hash), like to SHA-512 for example.
  Thus, you do not need to worry about what if the store file is leaked.
</Callout>
