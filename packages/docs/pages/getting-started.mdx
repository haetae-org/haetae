import { Callout } from 'nextra-theme-docs'
import PkgManagerTabs from '../components/PkgManagerTabs'
import TokenLinkCode from '../components/TokenLinkCode'

# Getting Started

Haetae is incremental task runner.<br/>
The task can be test, lint, build, or anything.<br/>
It can be used in any project, no matter what language, framework, test runner, linter/formatter, or build system you use.<br/>

For now, in this article, we are starting from an example of incremental testing.

## Why?

Let's say you're building a calculator project, named *'my-calculator'*.

```fish
my-calculator
â”œâ”€â”€ package.json
â”œâ”€â”€ src
â”‚Â Â  â”œâ”€â”€ add.js
â”‚Â Â  â”œâ”€â”€ exponent.js
â”‚Â Â  â”œâ”€â”€ multiply.js
â”‚Â Â  â””â”€â”€ subtract.js
â””â”€â”€ test
    â”œâ”€â”€ add.test.js
    â”œâ”€â”€ exponent.test.js
    â”œâ”€â”€ multiply.test.js
    â””â”€â”€ subtract.test.js
```

Dependency graph is like this.

<img src="/getting-started/dependency-graph.svg" alt="Dependeny graph of 'my-calculator'"/>

*`exponent.js`* depends on *`multiply.js`*, which depends on *`add.js`* and so on.

When testing, we should take the dependency graph into account.<br/>
We do NOT have to test all files (*`*.test.js`*) for every single tiny change <small>(Waste of your CI resources and time)</small>.<br/>
Rather, **we should do it incrementally, which means testing only files affected by the changes.**

For example, when *`multiply.js`* is changed, test only *`exponent.test.js`* and *`multiply.test.js`*.<br/>
When *`add.js`* is changed, test all files (<small>*`exponent.test.js`*, *`multiply.test.js`*, *`subtract.test.js`* and *`add.test.js`*</small>).<br/>
When test file <small>(e.g. *`add.test.js`*)</small> is changed, then just only execute the test file itself <small>(e.g. *`add.test.js`*)</small>.

Then how can we do it, automatically?<br/>
Here's where **Haetae** comes in.<br/>
By just a simple config, Haetae can automatically detect the dependency graph and test only affected files.<br/>
<small>(You do not have to change your test runner. In this article, [Jest](https://jestjs.io) is used just as an example.)</small>

## Installation

So, let's install Haetae. (<small>Node 16 or higher is required.</small>)<br/>
It doesn't matter whether your project is new or existing <small>(Haetae can be incrementally adapted)</small>.<br/>
It's so good for monorepo as well. <small>(Guided later in other part of docs.)</small><br/>
Literally **any project** is proper.

<br/>

<PkgManagerTabs>
```bash
npm install --save-dev haetae
```
```bash
yarn add --dev haetae
```
```bash
pnpm add --save-dev haetae
```
</PkgManagerTabs>

<Callout>
  **Are you developing a library (e.g. plugin) for Haetae?** <br/>
  You can depend on [`@haetae/core{:ts}`](apis/haetae-core), [`@haetae/utils{:ts}`](apis/haetae-utils),
  [`@haetae/git{:ts}`](apis/haetae-git), [`@haetae/javascript{:ts}`](apis/haetae-javascript),
  [`@haetae/cli{:ts}`](apis/haetae-cli) independently. Note that the package [`haetae{:ts}`](apis/haetae)
  include all of them.
</Callout>

## Basic configuration

Now, we are ready to configure Haetae.<br/>
Let's create a config file *`haetae.config.js`*.<br/>

```fish
my-calculator
â”œâ”€â”€ haetae.config.js # <--- Haetae config file
â”œâ”€â”€ package.json
â”œâ”€â”€ src # contents are omitted for brevity
â””â”€â”€ test # contents are omitted for brevity
```

<Callout>
  **Typescript Support** <br/>
  If you use typescript, it can be *`haetae.config.ts`*.
  Then install [`ts-node`](https://www.npmjs.com/package/ts-node) as `peerDependencies`.
  You need `ts-node` no matter if you actually use it directly or not.
  The `peerDependencies` is marked as optional, which means non-typescript users don't have to install it.
</Callout>

<Callout>
  **CJS/ESM** <br/>
  Haetae supports both CJS and ESM project. <br/>
  Haetae is written in ESM, but it can be used in CJS projects as well, as long as the config file is ESM.
  If your project is CJS, name the config file *`haetae.config.mjs`* or *`haetae.config.mts`*.
  If your project is ESM, name the config file *`haetae.config.js`* or *`haetae.config.ts`*.
</Callout>

We can write it down like this.<br/>
Make sure you initialized git. Haetae can be used with any other version control systems, but using git is assumed in this article.

<TokenLinkCode tokens={{
  'configure': './apis/haetae#configure',
  '.changedFiles': './apis/haetae-git#changedfiles',
  '.glob': './apis/haetae-utils#glob',
  '.dependsOn': './apis/haetae-javascript#dependson',
  '.exec': './apis/haetae-utils#exec',
}}>
```js filename="haetae.config.js"
import { configure, git, utils, js } from 'haetae'

export default configure({
  // Other options are ommitted for brevity.
  commands: {
    myTest: {
      run: async () => {
        // An array of changed files
        const changedFiles = await git.changedFiles()
        /* An array of test files.
          ['/path/to/my-calculator/test/exponent.test.js',
           '/path/to/my-calculator/test/multiply.test.js',
           '/path/to/my-calculator/test/subtract.test.js',
           '/path/to/my-calculator/test/add.test.js'] */
        const testFiles = await utils.glob(['**/*.test.js'])
        // An array of test files which (transitively) depend on changed files
        const affectedTestFiles = testFiles.filter((testFile) =>
          js.dependsOn({
            dependent: testFile,
            dependencies: changedFiles,
          })
        )

        if (affectedTestFiles.length > 0) {
          // Equals to "pnpm jest /path/to/foo.test.ts /path/to/bar.test.ts ..."
          // Change 'pnpm' and 'jest' to your package manager and test runner.
          await utils.exec(`pnpm jest ${affectedTestFiles.join(' ')}`)
        }
      },
    },
  },
})
```
</TokenLinkCode>

Multiple APIs are used in the config file above.<br/>
They all have various options <small>(Check out API docs)</small>.
But we are going to use their sensible defaults for now.<br/>
In the above config, `pnpm jest` is used in [`utils.exec(){:ts}`](./apis/haetae-utils#exec).
Just change them to your package manager and test runner.<br/>

Then run `haetae` like below.

```bash
$ haetae myTest
```
<small>(Unless you installed `haetae` globally, you should execute it through package manager (e.g. `pnpm haetae myTest`))</small>

Note that `myTest` in the command above is the name of the command we defined in the config file.<br/>
It will print the result like this.

```bash filename="terminal"
âœ”  success   Command myTest is successfully executed.

âŽ¡ ðŸ•— time: 2023 May 28 11:06:06 (timestamp: 1685239566483)
âŽœ ðŸŒ± env: {}
âŽœ ðŸ’¾ data:
âŽœ      "@haetae/git":
âŽœ        commit: 979f3c6bcafe9f0b81611139823382d615f415fd
âŽœ        branch: main
âŽ£        pkgVersion: 0.0.12
```

As this is the first time of running the command `haetae myTest`,
[`git.changedFiles(){:ts}`](./apis/haetae-git#changedfiles) in the config returns every file tracked by git in your project as changed files
<small>(There are [options](./apis/haetae-git#changedfiles). Check out API docs after reading this article)</small>.
This behavior results in running all of the tests.<br/>

[`js.dependsOn(){:ts}`](./apis/haetae-javascript#dependson) detects direct or transitive dependencies between files, by parsing `import` or `require()` and so on.
So it can be used to detect which test files depend on at least one of changed files.<br/>

<Callout>
**`js.dependsOn` can detect multiple formats**<br/>
ES6(.js, .mjs), CJS(.js, .cjs), AMD, TypeScript(.ts, .mts, .cts), JSX(.jsx, .tsx), Webpack Loaders, CSS Preprocessors(Sass, Scss, Stylus, Less), PostCSS, RequireJS are all supported.
For node, [Subpath Imports](https://nodejs.org/api/packages.html#subpath-imports) and [Subpath Exports](https://nodejs.org/api/packages.html#subpath-exports) are also supported.
For TypeScript, [Path Mapping](https://www.typescriptlang.org/docs/handbook/module-resolution.html#path-mapping) is also supported.
Check out the API docs and pass additional option(s) if you use Typescript or Webpack.
</Callout>

Note that it can not parse dynamic imports.
Dynamic or extra dependencies can be specified as `additionalGraph` option, which is explained later in this article.

May you have noticed, the store file *`.haetae/store.json`* is generated.
It stores history of Haetae executions, which makes incremental tasks possible.
For example, the commit ID `979f3c6` printed from the above output is the current git HEAD `haetae myTest` ran on.
This information is logged in the store file to be used later.

```fish
my-calculator
â”œâ”€â”€ .haetae/store.json # <--- Generated
â”œâ”€â”€ haetae.config.js
â”œâ”€â”€ package.json
â”œâ”€â”€ src
â””â”€â”€ test
```

## Detecting the last commit Haetae ran on successfully

Let's say we made some changes and added 2 commits.

<img src="/getting-started/commit-history.svg" alt="Commit history after the first running of Haetae"/>

`979f3c6` is the last commit Haetae ran on successfully.<br/>
What will happen when we run Haetae again?

```bash
$ haetae myTest
```

This time, only *`exponent.test.js`* and *`multiply.test.js`* are executed.<br/>
That's because [`git.changedFiles(){:ts}`](./apis/haetae-git#changedfiles) automatically returns only the files changed since the last successful execution of Haetae.
For another example, if you modify `add.js`, then all tests will be executed, because [`js.dependsOn(){:ts}`](./apis/haetae-javascript#dependson) works **transitively**.
```bash filename="terminal"
âœ”  success   Command myTest is successfully executed.

âŽ¡ ðŸ•— time: 2023 May 28 19:03:25 (timestamp: 1685268205443)
âŽœ ðŸŒ± env: {}
âŽœ ðŸ’¾ data:
âŽœ      "@haetae/git":
âŽœ        commit: 1d17a2f2d75e2ac94f31e53376c549751dca85fb
âŽœ        branch: main
âŽ£        pkgVersion: 0.0.12
```

Accordingly, the new commit `1d17a2f` is logged in the store file.<br/>

The output above is an example of successful task.
Conversely, if the test fails, [`utils.exec(){:ts}`](./apis/haetae-utils#exec) in the config throws an error.
So `myTest.run(){:ts}` is not completed successfully, causing the store file is not renewed.<br/>

This behavior is useful for incremental tasks.
The failed test (or any incremental task) will be re-executed later until the problem is fixed.

## `env` configuration

Sometimes we need to separate several environments.<br/>
For example, logic of your project might act differently depending on the environment variable `$NODE_ENV`.<br/>
So, the history of an incremental task also should be recorded for each environment in a separated manner.<br/>
Let's add `env` to the config file to achieve this.

<TokenLinkCode tokens={{
  'configure': './apis/haetaes#configure',
}}>
```js filename="haetae.config.js" {6-8}
import { configure, git, utils, js } from 'haetae'

export default configure({
  commands: {
    myTest: {
      env: { // <--- Add this
        NODE_ENV: process.env.NODE_ENV,
      },
      run: async () => { /* ... */ },
    },
  },
})
```
</TokenLinkCode>

From now on, the store file will manage the history of each environment separately.
The key name `NODE_ENV` is just an example. You can name it as you want.<br/>

You don't have to care about the past history of `myTest` executed without `env`.
When a command is configured without `env`, it's treated as if configured with `env: {}`, which is totally fine.
The past history in the store file is NOT automatically deleted just by the change of the config file.
It is OK to keep the history of the past executions, unless you don't want <small>(A way to delete past history is guided later)</small>.<br/>

Of course, you can add more keys in `env` object.<br/>
For instance, let's change the config like this.<br/>

<TokenLinkCode tokens={{
  'configure': './apis/haetaes#configure',
  '.hash': './apis/haetae-utils#hash',
  '.version': './apis/haetae-javascript#version',
  '.branch': './apis/haetae-git#branch',
}}>
```js filename="haetae.config.js"
import assert from 'node:assert/strict'
import { configure, git, utils, js } from 'haetae'

export default configure({
  commands: {
    myTest: {
      env: async () => { // <--- Changed to async function from object
        assert(['development', 'production'].includes(process.env.NODE_ENV))
        return {
          dotenvAndJestConfig: await utils.hash([
            `.env.${process.env.NODE_ENV}`,
            'jest.config.js',
          ]),
          jest: (await js.version('jest')).major,
          branch: await git.branch(),
        }
      },
      run: async () => { /* ... */ },
    },
  },
})
```
</TokenLinkCode>

The object has more keys than before, named `dotenvAndJestConfig`, `jest`, `branch`.
If any of dotenv file, jest config file, jest's major version, or git branch is changed,
it's treated as a different environment.

And now it's a function. You can even freely write any additional code in it, like assertion (`assert(){:ts}`) in the example above.
Just as like `myTest.run(){:ts}`, when an error is thrown in `myTest.env(){:ts}`,
the store file is not renewed, which is good for incremental tasks.

<Callout>
  **Hash credentials** <br/>
  [`utils.hash(){:ts}`](./apis/haetae-utils#hash) is good for credentials like a dotenv file.
  By default, it hashes by SHA-256, and you can simply change it by its options, like to SHA-512 for example.
  Thus, you do not need to worry about what if the store file is leaked.
</Callout>

## Additional dependency graph

Until now, [`js.dependsOn(){:ts}`](./apis/haetae-javascript#dependson) is used for automatic detection of dependency graph.
But sometimes, you need to add some dependencies manually.<br/>

### Integration test

For example, let's say you're developing a web backend project.
There're SQL files and Docker Compose file for integration test.
It is not explicitly imported by any JavaScript file.
In this kind of case, [`utils.graph(){:ts}`](./apis/haetae-utils#graph) and `options.additionalGraph` of [`js.dependsOn(){:ts}`](./apis/haetae-javascript#dependson) are useful.<br/>

<TokenLinkCode tokens={{
  'configure': './apis/haetaes#configure',
  '.changedFiles': './apis/haetae-git#changedfiles',
  '.glob': './apis/haetae-utils#glob',
  '.graph': './apis/haetae-utils#graph',
  '.dependsOn': './apis/haetae-javascript#dependson',
}}>
```js filename="haetae.config.js" {10-21,26,}
import { configure, git, utils, js } from 'haetae'

export default configure({
  commands: {
    myTest: {
      env: { /* ... */ },
      run: async () => {
        const changedFiles = await git.changedFiles()
        const testFiles = await utils.glob(['**/*.test.js'])
        // A graph of additional dependencies specified manually
        const additionalGraph = utils.graph({
          edges: [
            {
              dependents: await utils.glob(['test/db/*.test.js']),
              dependencies: [
                'test/docker-compose.yml',
                ...(await utils.glob(['test/db/*.sql'])),
              ],
            },
          ],
        })
        const affectedTestFiles = testFiles.filter((testFile) =>
          js.dependsOn({
            dependent: testFile,
            dependencies: changedFiles,
            additionalGraph, // <--- New option
          }),
        )

        if (affectedTestFiles.length > 0) {
          await utils.exec(`pnpm jest ${affectedTestFiles.join(' ')}`)
        }
      },
    },
  },
})
```
</TokenLinkCode>

The config lets Haetae think that *`test/db/*.test.js`* depend on *`test/docker-compose.yml`* and *`test/db/*.sql`*, like the dependency graph below.
This graph is purely additional.
The original dependency graph automatically drawn by [`js.dependsOn(){:ts}`](./apis/haetae-javascript#dependson) still works.<br/>

<img src="/getting-started/additional-dependency-graph.svg" alt="Additional Dependency Graph"/>

The effect of `addtionalGraph` is different from `env`.
Execution history is recorded separately by value of `env`.
It's like parallel universes.
So `env` sets boundaries of where the concept of *'increment'* of history is defined.
If you place Docker Compose and SQL files in `env` (e.g. by [`utils.hash(){:ts}`](./apis/haetae-utils#hash)) instead of `additonalGraph`,
every test files will be executed when any of Docker Compose or SQL files changes,
unless the change of Docker Compose or SQL files is  rollback to past content which can be matched with a past value of `env` logged in the store file.

If *`test/db/*.test.js`* is the only test files, this behavior is OK.
However, if there're others, like *`test/utils/*.test.js`*, this is not ideal.
Because *`test/utils/*.test.js`* should not be affected by the change of Docker Compose or SQL files.
That's why `additionalGraph` is useful.
It makes sure *`test/utils/*.test.js`* are NOT executed when Docker Compose or SQL files are changed, unlike *`test/db/*.test.js`*.

### Dotenv

`additionalGraph` is not just for test files.
Source files can also get benefit from it.
In the previous section ("[`env` configuration](#env-configuration)"), we dealt with handling dotenv <small>(.env)</small> file with Haetea's `env`.
This can be done with `additionalGraph` as well. In fact, using `env` and `additionalGraph` together is the best in genreal.<br/>

Let's say you have a single *`.env`* file.

```fish
your-project
â”œâ”€â”€ .env
â”œâ”€â”€ haetae.config.js
â”œâ”€â”€ package.json
â”œâ”€â”€ src
â”‚Â Â  â”œâ”€â”€ config.js
â”‚Â Â  â”œâ”€â”€ utils.js
â”‚Â Â  â”œâ”€â”€ logic.js
â”‚Â Â  â””â”€â”€ index.js
â””â”€â”€ test
    â”œâ”€â”€ utils.test.js
    â”œâ”€â”€ logic.test.js
    â””â”€â”€ index.test.js
```

*`src/config.js`* reads the file, by a library [dotenv](https://www.npmjs.com/package/dotenv) for example.

```js filename="src/config.js"
import { config } from 'dotenv'

config()

export default {
  port: process.env.PORT,
  secretKey: process.env.SECRET_KEY,
  env: process.env.ENV
}
```

Dependency graph is like this.
Let's assume *`logic.js`* gets the value of environment variables through *`config.js`*, not directly reading from *`.env`* or `process.env{:ts}`.

<img src="/getting-started/dependency-graph-with-dotenv.svg" alt="Dependency graph"/>

Let Haetae think *`config.js`* depends on *`.env`*.

<TokenLinkCode tokens={{
  '.graph': './apis/haetae-utils#graph',
}}>
```js filename="haetae.config.js" {4-7}
// Other content is ommitted for brevity.
const additionalGraph = utils.graph({
  edges: [
    {
      dependents: ['src/config.js'],
      dependencies: ['.env'],
    },
  ],
})
```
</TokenLinkCode>

Then the dependency graph becomes explicit.

<img src="/getting-started/dependency-graph-with-dotenv-focus.svg" alt="Dependency graph with .env"/>

<TokenLinkCode tokens={{
  'configure': './apis/haetaes#configure',
  '.changedFiles': './apis/haetae-git#changedfiles',
  '.glob': './apis/haetae-utils#glob',
  '.graph': './apis/haetae-utils#graph',
  '.dependsOn': './apis/haetae-javascript#dependson',
}}>
```js filename="haetae.config.js" {13-14,}
import { configure, git, utils, js } from 'haetae'

export default configure({
  commands: {
    myTest: {
      env: { /* ... */ },
      run: async () => {
        const changedFiles = await git.changedFiles()
        const testFiles = await utils.glob(['**/*.test.js'])
        const additionalGraph = utils.graph({
          edges: [
            {
              dependents: ['src/config.js'],
              dependencies: ['.env'],
            },
          ],
        })
        const affectedTestFiles = testFiles.filter((testFile) =>
          js.dependsOn({
            dependent: testFile,
            dependencies: changedFiles,
            additionalGraph,
          }),
        )

        if (affectedTestFiles.length > 0) {
          await utils.exec(`pnpm jest ${affectedTestFiles.join(' ')}`)
        }
      },
    },
  },
})
```
</TokenLinkCode>


## Custom record data
