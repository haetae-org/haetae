import { Callout } from 'nextra-theme-docs'
import Link from 'next/link'
import PkgManagerTabs from '../../components/PkgManagerTabs'
import TokenLinkCode from '../../components/TokenLinkCode'
import Chip from '../../components/Chip'

export const Memoized = () => (<Chip label='Memoized' href='./introduction#memoization' />)
export const PathPrinciples = () => (<Chip label='Path Principles' href='./introduction/#path-principles' />)

# `@haetae/utils{:ts}`

`@haetae/utils{:ts}` provides useful unitlities for general Heatae workflow.

## `peerDependencies`

**Note**: This might not be exhaustive and lists only Haetae's packages.

- [`@haetae/core{:ts}`](./haetae-core)

## Dependents

- [`haetae{:ts}`](./haetae)
- [`@haetae/javascript{:ts}`](./haetae-javascript)
- [`@haetae/git{:ts}`](./haetae-git)

## Installation

<Callout>
  **Are you developing a library(e.g. plugin) for Haetae?** <br />
  It might be more suitable to specify `@haetae/utils` as `peerDependencies` than `dependencies`.
</Callout>

### To automatically install `@haetae/utils{:ts}` and its `peerDependencies`

You may want to install `@haetae/utils{:ts}` and its `peerDependencies` all at once. <br/>
[`install-peerdeps`](https://www.npmjs.com/package/install-peerdeps) is a good tool for that.

<br/>

<PkgManagerTabs>
```bash
# As dependencies
npx install-peerdeps @haetae/utils
# As devDependencies
npx install-peerdeps --dev @haetae/utils
```
```bash
# As dependencies
npx install-peerdeps --yarn @haetae/utils
# As devDependencies
npx install-peerdeps --yarn --dev @haetae/utils
```
```bash
# As dependencies
npx install-peerdeps --pnpm @haetae/utils
# As devDependencies
npx install-peerdeps --pnpm --dev @haetae/utils
```
</PkgManagerTabs>

### To manually handle installation

You might want to manually deal with installation.<br/>
First, install `@haetae/utils{:ts}` itself.

<br/>

<PkgManagerTabs>
```bash
# As dependencies
npm install @haetae/utils
# As devDependencies
npm install --save-dev @haetae/utils
```
```bash
# As dependencies
yarn add @haetae/utils
# As devDependencies
yarn add --dev @haetae/utils
```
```bash
# As dependencies
pnpm add @haetae/utils
# As devDependencies
pnpm add --save-dev @haetae/utils
```
</PkgManagerTabs>

Then, check out `peerDependencies` and manually handle them.<br/>
(e.g. Install them as `dependencies` or set them as `peerDependencies`)

```bash
# This does not install, but just show peerDependencies.
npm info @haetae/utils peerDependencies
```

## API

### `pkg`

Refer to [introduction#pkg](./introduction#pkg).

### `RecordData`

```ts
interface RecordData extends Rec {
  '@haetae/utils': {
    files?: Record<string, string>
    pkgVersion: string
  }
}
```

<Callout>
  **Record Data Namespace**<br/>
  *Record Data* can have arbitrary fields.
  `'@haetae/utils'{:ts}` is a namespace to avoid collision.
  Haetae uses a package name as a namespace by convention.
</Callout>

### `RecordDataOptions`

An argument interface for `recordData`

```ts
interface RecordDataOptions {
  files?: Record<string, string>
  pkgVersion?: string
}
```

### `recordData`

A function to form *Record Data* `@haetae/utils{:ts}` manages.

**Type**

<TokenLinkCode tokens={['RecordDataOptions', 'RecordData']}>
```ts
(options?: RecordDataOptions) => Promise<RecordData>
```
</TokenLinkCode>

**Options?**

- `files?{:ts}` : filename-hash pairs.
- `pkgVersion?{:ts}` : Version of `@haetae/utils{:ts}`. <small>(default: [`pkg.version.value{:ts}`](./introduction#pkg))</small>


### `GlobOptions`

A function to add a new record under the given command to store.

[`GlobbyOptions`](https://github.com/sindresorhus/globby/tree/v13.1.4#options), which is part of `GlobOptions`, is from [**globby**](https://github.com/sindresorhus/globby/tree/v13.1.4).

<TokenLinkCode tokens={{ 'GlobbyOptions': 'https://github.com/sindresorhus/globby/tree/v13.1.4#options'}}>
```ts
interface GlobOptions {
  rootDir?: string // A facade option for `globbyOptions.cwd`
  globbyOptions?: GlobbyOptions
}
```
</TokenLinkCode>

### `glob`
<br/>
<PathPrinciples/>

A function to find files by a glob pattern.<br/>
Internally, the task is delegated to [**`globby`**](https://github.com/sindresorhus/globby/tree/v13.1.4)
<small>(v13 as of writing)</small>.<br/>
`glob` is a [facade function](https://en.wikipedia.org/wiki/Facade_pattern) for `globby`,
providing more handy experience by default options and postprocessing.

**Type**

<TokenLinkCode tokens={['GlobOptions']}>
```ts
(patterns: readonly string[], options?: GlobOptions) => Promise<string[]>
```
</TokenLinkCode>

**Arguments**

- `patterns{:ts}`: Array of glob patterns. <small>(e.g. `['**/*.test.ts', '**/*.test.tsx']{:ts}`)</small>
- `options?{:ts}` :
  - `options.rootDir?{:ts}` : A directory to start search.
  If `options.globbyOptions.cwd{:ts}` is not provided (`undefined{:ts}`), this value is used.
  Ignored otherwise. <small>(default: [`core.getConfigDirname(){:ts}`](./haetae-core#getconfigdirname))</small>
  - `options.globbyOptions?{:ts}` : Refer to [globby v13 docs](https://github.com/sindresorhus/globby/tree/v13.1.4).

### `ExecOptions`

An argument interface for [`exec`](#exec).

```ts
interface ExecOptions {
  uid?: number | undefined
  gid?: number | undefined
  cwd?: string | URL | undefined
  env?: NodeJS.ProcessEnv | undefined
  windowsHide?: boolean | undefined
  timeout?: number | undefined
  shell?: string | undefined
  maxBuffer?: number | undefined
  killSignal?: NodeJS.Signals | number | undefined
  trim?: boolean // An option added from Haetae side. (Not for `childProcess.exec`)
}
```

### `exec`

A function to execute a script.<br/>
Internally, nodejs's [`childProcess.exec{:ts}`](https://nodejs.org/api/child_process.html#child_processexeccommand-options-callback) is used.

**Type**

<TokenLinkCode tokens={['ExecOptions']}>
```ts
(command: string, options?: ExecOptions) => Promise<string>
```
</TokenLinkCode>

**Arguments**

- `command` : An arbitrary command to execute on shell.
This command does NOT mean haetae's **command** concept.
- `options?{:ts}` : Options for `childProcess.exec{:ts}`.
Refer to [the nodejs official docs](https://nodejs.org/api/child_process.html#child_processexeccommand-options-callback).
  - `options.trim?{:ts}` : Some commands' result (**stdout**, **stderr**) ends with whitespace(s) or line terminator character (e.g. `\n{:ts}`).
  If `true{:ts}`, the result would be automatically [trimmed](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/Trim).
  If `false{:ts}`, the result would be returned as-is.
  `options.trim{:ts}` is the only option not a part of `childProcess.exec{:ts}`'s original options.

### <Link id="dollar-exec" href="#dollar-exec">`$Exec`</Link>

Type of [`$`](#dollar).<br/>
It's an interface for function, but simultaneously [`ExecOptions`](#execoptions).

**Type**

<TokenLinkCode tokens={['ExecOptions']}>
```ts
interface $Exec extends ExecOptions {
  (
    statics: TemplateStringsArray,
    ...dynamics: readonly PromiseOr<
      string | number | PromiseOr<string | number>[]
    >[]
  ): Promise<string>
}
```
</TokenLinkCode>

### <Link id="dollar" href="#dollar">`$`</Link>

A wrapper of [`exec`](#exec) as a [Tagged Template](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Template_literals#tagged_templates).<br/>
It can have properties as options ([`ExecOptions`](#execoptions)) of [`exec`](#exec).

**Type**

<TokenLinkCode tokens={{ '$Exec': '#dollar-exec' }}>
```ts
$Exec
```
</TokenLinkCode>

#### Usage

You can execute any shell command.

```js
const stdout = await $`echo hello world`
assert(stdout === 'hello world')
```

Placeholders can be used. `Promise` is automatically awaited internally.

```js
const stdout = await $`echo ${123} ${'hello'} ${Promise.resolve('world')}`
assert(stdout === '123 hello world')
```

When a placeholder is an array, a white space (`' '`) is joined between the elements.

```js
// Array
let stdout = await $`echo ${[Promise.resolve('hello'), 'world']}`
assert(stdout === 'hello world')

// Promise<Array>
stdout = await $`echo ${Promise.resolve([
  Promise.resolve('hello'),
  'world',
])}`
assert(stdout === 'hello world')
```

It can have properties as options ([`ExecOptions`](#execoptions)) of [`exec`](#exec).<br/>
The state of properties of `$` does not take effect when independently calling [`exec`](#exec).

```js
$.cwd = '/path/to/somewhere'
const stdout = await $`pwd`
assert(stdout === '/path/to/somewhere')
```


### `HashOptions`

An argument interface for [`hash`](#hash).

```ts
interface HashOptions {
  algorithm?: 'md5' | 'sha1' | 'sha256' | 'sha512'
  rootDir?: string
}
```

### `hash`

A function to hash files.<br/>
It reads content of a single or multiple file(s), and returns a cryptographic hash string.<br/>

<Callout>
**Sorted Merkle Tree** <br />
When multiple files are given, they are treated as a single depth [Merkle Tree](https://en.wikipedia.org/wiki/Merkle_tree).
However, the files are sorted by their path before hashed,
resulting in same result even when different order is given.
For example, `hash(['foo.txt', 'bar.txt'])` is equal to `hash(['bar.txt', 'foo.txt'])`.
</Callout>

**Type**

<TokenLinkCode tokens={['HashOptions']}>
```ts
(files: string[], options?: HashOptions) => Promise<string>
```
</TokenLinkCode>

**Arguments**

- `files{:ts}` : Files to hash. <small>(e.g. `['package.json', 'package-lock.json']{:ts}`)</small>
- `options?{:ts}`
  - `options.algorithm?{:ts}` : An hash algorithm to use. <small>(default: `'sha256'{:ts}`)</small>
  - `options.rootDir?{:ts}` : A directory to start file search.
  When an element of `files{:ts}` is relative (not absolute), this value is used. Ignored otherwise.
  <small>(default: [`core.getConfigDirname(){:ts}`](./haetae-core#getconfigdirname))</small>

#### Usage

`env` in the config file can be a good place to use `hash`.

<TokenLinkCode tokens={{
  '.configure': './haetae-core#configure',
  '.version': './haetae-javascript#version',
  }}>
```js filename="haetae.config.js"
import { core, utils, js } from 'haetae'

export default core.configure({
  // Other options are omitted for brevity.
  commands: {
    myTest: {
      env: async () => ({
        hash: await utils.hash([
          'jest.config.js',
          'package-lock.json',
        ])
      }),
      run: async () => { /* ... */ }
    },
    myLint: {
      env: async () => ({
        eslintrc: await utils.hash(['.eslintrc.js']),
        eslint: (await js.version('eslint')).major
      }),
      run: async () => { /* ... */ }
    }
  },
})
```
</TokenLinkCode>

#### Usage with `glob`

If you target many files, consider using [`glob`](#glob) with `hash`.

<TokenLinkCode tokens={['.glob']}>
```js
await utils.hash([
  'foo',
  ...(await utils.glob(['bar/**/*'])),
])
```
</TokenLinkCode>

### `DepsEdge`

An interface resolving dependencies edge. <br/>
<small>**TIP**. The prefix **Deps** stands for 'Dependencies'.</small>

```ts
interface DepsEdge {
  dependents: readonly string[]
  dependencies: readonly string[]
}
```

### `GraphOptions`

An argument interface for [`graph`](#graph).

<TokenLinkCode tokens={['DepsEdge']}>
```ts
interface GraphOptions {
  edges: readonly DepsEdge[]
  rootDir?: string
}
```
</TokenLinkCode>

### `DepsGraph`

An return type of [`graph`](#graph).<br/>
Its structure is similar to the traditional ['Adjacency List'](https://en.wikipedia.org/wiki/Adjacency_list).<br/>
<small>**TIP**. The prefix **Deps** stands for 'Dependencies'.</small>

```ts
interface DepsGraph {
  // key is dependent. Value is Set of dependencies.
  [dependent: string]: Set<string>
}
```

### `graph`
<br/>
<PathPrinciples/>

A function to create a dependency graph.<br/>
Unlike [`js.graph{:ts}`](./haetae-javascript#graph), it's not just for a specific language, but for *any* dependency graph.

**Type**

<TokenLinkCode tokens={['GraphOptions', 'DepsGraph']}>
```ts
(options?: GraphOptions) => DepsGraph
```
</TokenLinkCode>

**Options?**

- `edges{:ts}` : A single or multiple edge(s). The `dependents` and `dependencies` have to be file path, not directory.
- `rootDir?{:ts}` : When an element of `dependents` and `dependencies` is given as a relative path,
`rootDir{:ts}` is joined to transform it to an absolute path.
<small>(default: [`core.getConfigDirname(){:ts}`](./haetae-core#getconfigdirname))</small>

#### Basic Usage

You can specify any dependency relationship.<br/>
This is just a pure function. Whether the files depend on each other does not matter.

```ts
const result = graph({
  rootDir: '/path/to',
  edges: [
    {
      dependents: ['src/foo.tsx', 'src/bar.ts'],
      dependencies: ['assets/one.png', 'config/another.json'],
    },
    {
      // 'src/bar.ts' appears again, and it's OK!
      dependents: ['src/bar.ts', 'test/qux.ts'],
      // Absolute path is also OK!
      dependencies: ['/somewhere/the-other.txt'],
    },
  ],
})

const expected = {
  '/path/to/src/foo.tsx': new Set([
    '/path/to/assets/one.png',
    '/path/to/config/another.json',
  ]),
  '/path/to/src/bar.ts': new Set([
    '/path/to/assets/one.png',
    '/path/to/config/another.json',
    '/somewhere/the-other.txt',
  ]),
  '/path/to/test/qux.ts': new Set([
    '/somewhere/the-other.txt', // Absolute path is preserved.
  ]),
  '/path/to/assets/one.png': new Set([]),
  '/path/to/config/another.json': new Set([]),
  '/somewhere/the-other.txt': new Set([]),
}

assert(deepEqual(result, expected)) // They are same.
```

#### Usage With `glob`

[`glob`](#glob) is a good friend when you want to specify chunk-level dependency relationships.<br/>

Let's say you have multiple Python projects (packages) in a single monorepo.<br/>
For example, packages '*foo*' and '*bar*' depend on a package '*qux*'.<br/>
Then you can create a normalized dependency graph like the snippet below.

```ts
graph({
  edges: [
    {
      dependents: await glob(['packages/foo/**/*.py', 'packages/bar/**/*.py']),
      dependencies: await glob(['packages/qux/**/*.py']),
    },
  ],
})
```

### `mergeGraphs`

A function to merge multiple dependency graphs into one single unified graph.

<TokenLinkCode tokens={['DepsGraph']}>
```ts
(graphs : DepsGraph[]) => DepsGraph
```
</TokenLinkCode>


### `DependsOnOptions`

An argument interface for [`dependsOn`](#dependson).

<TokenLinkCode tokens={['DepsGraph']}>
```ts
interface DependsOnOptions {
  dependent: string
  dependencies: readonly string[] | Set<string>
  graph: DepsGraph
  rootDir?: string
}
```
</TokenLinkCode>

### `dependsOn`

A function to check if a file depends on one of different files, transitively or directly.

<TokenLinkCode tokens={['DependsOnOptions']}>
```ts
(options: DependsOnOptions) => boolean
```
</TokenLinkCode>

**Options**

- `dependent{:ts}` : A target to check if it is a dependent of at least one of `dependencies{:ts}`, directly or transitively.
- `dependencies{:ts}` : A list of candidates that may be a dependency of dependent, directly or transitively.
- `graph{:ts}` : A graph. Return value of [`graph`](#graph) is proper.
- `rootDir?{:ts}` : When `dependent` or an element of `dependencies` is given as a relative path,
`rootDir{:ts}` is joined to transform it to an absolute path.
<small>(default: [`core.getConfigDirname(){:ts}`](./haetae-core#getconfigdirname))</small>

#### Basic Usage

Let's say,

- ***a*** depends on ***b***.
- ***c*** depends on ***a***, which depends on ***b***
- ***e*** does not (even transitively) depend on neither ***f*** nor ***b***.
- ***f*** does not (even transitively) depend on ***b***.

then the result would be like this.

<TokenLinkCode tokens={{'.graph': '#graph'}}>
```js
const graph = utils.graph({
  edges: [
    {
      dependents: ['a'],
      dependencies: ['b'],
    },
    {
      dependents: ['c'],
      dependencies: ['a'],
    },
    {
      dependents: ['f'],
      dependencies: ['another', 'another2'],
    },
  ],
})

utils.dependsOn({ dependent: 'a', dependencies: ['f', 'b'], graph }) // true
utils.dependsOn({ dependent: 'c', dependencies: ['f', 'b'], graph }) // true -> transitively
utils.dependsOn({ dependent: 'f', dependencies: ['f', 'b'], graph }) // true -> 'f' depends on 'f' itself.
utils.dependsOn({ dependent: 'non-existent', dependencies: ['f', 'b'], graph }) // false -> `graph[dependent] === undefined`, so false
utils.dependsOn({ dependent: 'a', dependencies: ['non-existent']), graph }) // false
utils.dependsOn({ dependent: 'c', dependencies: ['non-existent', 'b']), graph }) // true -> at least one (transitive) dependency is found
```
</TokenLinkCode>

### `ChangedFilesOptions`

An argument interface for [`changedFiles{:ts}`](#changedfiles).

```ts
interface ChangedFilesOptions {
  rootDir?: string
  hash?: (filename: string) => PromiseOr<string>
  filterByExistence?: boolean
  reserveRecordData?: boolean
}
```

### `changedFiles`
<br/>
<Memoized/>
<PathPrinciples/>

A function to get a list of changed files.<br/>
[Getting Started](../getting-started) guide explains its principles.

**Type**

<TokenLinkCode tokens={['ChangedFilesOptions']}>
```ts
(files: readonly string[], options?: ChangedFilesOptions) => Promise<string[]>
```
</TokenLinkCode>

**Options?**

- `rootDir?{:ts}` : When an element of `files` is given as a relative path, rootDir is used to calculate the path.
  <small>(default: [`core.getConfigDirname(){:ts}`](./haetae-core#getconfigdirname).)</small>
- `hash?{:ts}` : A commit ID as a starting point of comparison.
  <small>(default: `(f) => _hash([f], { rootDir })`)</small>
- `filterByExistence?{:ts}` : Whether to filter out non-existent files before passing to `hash` function.
  <small>(default: `false{:ts}`)</small>
- `reserveRecordData?{:ts}` : Whether to reserve *Record Data*.
  <small>(default: `true{:ts}`)</small>
