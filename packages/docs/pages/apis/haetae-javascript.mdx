import { Callout } from 'nextra-theme-docs'
import PkgManagerTabs from '../../components/PkgManagerTabs'
import TokenLinkCode from '../../components/TokenLinkCode'

# `@haetae/javascript{:ts}`

`@haetae/javascript{:ts}` provides features for javascript ecosystem.<br/>
For instance, you can find out which module depends on which modules.<br/>
If your project do not use javascript-related languages, you don't need this package.

## `peerDependencies`

**Note**: This might not be exhaustive and lists only Haetae's packages.

- [`@haetae/core{:ts}`](./haetae-core)
- [`@haetae/utils{:ts}`](./haetae-utils)

## Dependents

- [`haetae{:ts}`](./haetae)

## Installation

<Callout>
  **Are you developing a library(e.g. plugin) for Haetae?** <br/>
  It might be more suitable to specify `@haetae/javascript` as `peerDependencies` than `dependencies`.
</Callout>

### To automatically install `@haetae/javascript{:ts}` and its `peerDependencies`

You may want to install `@haetae/javascript{:ts}` and its `peerDependencies` all at once. <br/>
[`install-peerdeps`](https://www.npmjs.com/package/install-peerdeps) is a good tool for that.

<br/>

<PkgManagerTabs>
```bash
# As dependencies
npx install-peerdeps @haetae/javascript
# As devDependencies
npx install-peerdeps --dev @haetae/javascript
```
```bash
# As dependencies
npx install-peerdeps --yarn @haetae/javascript
# As devDependencies
npx install-peerdeps --yarn --dev @haetae/javascript
```
```bash
# As dependencies
npx install-peerdeps --pnpm @haetae/javascript
# As devDependencies
npx install-peerdeps --pnpm --dev @haetae/javascript
```
</PkgManagerTabs>

### To manually handle installation

You might want to manually deal with installation.<br/>
First, install `@haetae/javascript{:ts}` itself.

<br/>

<PkgManagerTabs>
```bash
# As dependencies
npm install @haetae/javascript
# As devDependencies
npm install --save-dev @haetae/javascript
```
```bash
# As dependencies
yarn add @haetae/javascript
# As devDependencies
yarn add --dev @haetae/javascript
```
```bash
# As dependencies
pnpm add @haetae/javascript
# As devDependencies
pnpm add --save-dev @haetae/javascript
```
</PkgManagerTabs>

Then, check out `peerDependencies` and manually handle them.<br/>
(e.g. Install them as `dependencies` or set them as `peerDependencies`)

```bash
# This does not install, but just shows peerDependencies.
npm info @haetae/javascript peerDependencies
```

## API

### `pkg`

Refer to [introduction#pkg](./introduction#pkg).

### `VersionOptions`

An argument interface for [`version`](#version).

**Type**

```ts
interface VersionOptions {
  rootDir?: string
}
```

### `version`

A function to get the version (not SemVer range, but the exact real version) of installed packages.<br/>
<small>(Any packages, like `typescript`, `jest`, `react`, `@changesets/cli` etc.)</small><br/>
It supports npm, yarn classic(v1), yarn berry(v2, v3) and pnpm.

<Callout>
**Not For Global Package** <br/>
`version` only works for local packages installed for your project, not globally installed packages on your system.
</Callout>

**Type**

<TokenLinkCode tokens={['VersionOptions']}>
```ts
(packageName: string, options?: VersionOptions) => Promise<string>
```
</TokenLinkCode>

**Arguments**

- `packageName{:ts}` : A package name to get the version of.
- `options?{:ts}`
  - `options.rootDir?{:ts}` : A directory to start search.
  This should be your project root or its inner directory. <small>(default: [`core.getConfigDirname(){:ts}`](./haetae-core#getconfigdirname))</small>

#### Usage

You can get parsed object of any package's version by `version{:ts}`.<br/>
For example, let's assume eslint's version is ***`1.2.3-beta.4`***.

```ts
import * as js from '@haetae/javascript'

const eslintVersion = await js.version('eslint')

eslintVersion.value // '1.2.3-beta.4'
eslintVersion.major // 1 // Integer
eslintVersion.minor // 2 // Integer
eslintVersion.patch // 3 // Integer
eslintVersion.prerelease // ['beta', 4] // 'beta' is string, 4 is integer
eslintVersion.untilMinor //  '1.2'
eslintVersion.untilPatch // '1.2.3'
```

`env` in the config file can be a good place to use `version`.

<TokenLinkCode tokens={{
  '.configure': './haetae-core#configure',
  '.hash': './haetae-utils#hash',
}}>
```js filename="haetae.config.js"
import { core, js, utils } from 'haetae'

export default core.configure({
  // Other options are ommitted for brevity.
  commands: {
    myLint: {
      env: async () => ({
        eslintrc: await utils.hash(['.eslintrc.js']),
        eslint: (await js.version('eslint')).major,
      }),
      run: async () => { /* ... */ }
    }
  },
})
```
</TokenLinkCode>

### `GraphOptions`

An argument interface for [`graph`](#graph).

**Type**

```ts
interface GraphOptions {
  entrypoint: string
  tsConfig?: string
  rootDir?: string
}
```

### `graph`

A function to create a dependency graph.<br/>
it's not just for a specific language, but for *any* dependency graph.

**Type**

<TokenLinkCode tokens={{
  'GraphOptions': './GraphOptions',
  '.DepsGraph': './haetae-utils#depsgraph'
}}>
```ts
(options: GraphOptions) => utils.DepsGraph
```
</TokenLinkCode>

**Options?**

- `entrypoint{:ts}` : A starting point of a file to search the dependency graph.
- `tsConfig?{:ts}` : A path to Typescript config file. <small>(e.g. tsconfig.json)</small>.
- `rootDir?{:ts}` : A directory to use when `entrypoint` or `tsConfig` is given as relative paths.
<small>(default: [`core.getConfigDirname(){:ts}`](./haetae-core#getconfigdirname))</small>

### `DependsOnOptions`

An argument interface for [`dependsOn`](#dependson)

**Type**

<TokenLinkCode tokens={{ '.DepsGraph': './haetae-utils#depsgraph' }}>
```ts
interface DependsOnOptions {
  dependent: string
  dependencies: readonly string[]
  tsConfig?: string
  rootDir?: string
  additionalGraph?: utils.DepsGraph
}
```
</TokenLinkCode>

### `dependsOn`

A function to check if a module depends on one of the different modules, transitively or directly.<br/>

<Callout>
**Multiple Formats Support**<br/>
ES6(.js, .mjs), CJS(.js, .cjs), AMD, TypeScript(.ts, .mts, .cts), JSX(.jsx, .tsx), Webpack Loaders, CSS Preprocessors(Sass, Scss, Stylus, Less), PostCSS, RequireJS are all supported.
For node, [Subpath Imports](https://nodejs.org/api/packages.html#subpath-imports) and [Subpath Exports](https://nodejs.org/api/packages.html#subpath-exports) are also supported.
For TypeScript, [Path Mapping](https://www.typescriptlang.org/docs/handbook/module-resolution.html#path-mapping) is also supported.
</Callout>

**Type**

<TokenLinkCode tokens={['DependsOnOptions']}>
```ts
(options: DependsOnOptions) => boolean
```
</TokenLinkCode>

**Options?**

- `dependent{:ts}` : A target to check if it is a dependent of at least one of `dependencies{:ts}`, directly or transitively.
- `dependencies{:ts}` : Candidates that may be a dependency of dependent, directly or transitively.
- `tsConfig?{:ts}` : A path to typescript config file. <small>(e.g. **tsconfig.json**)</small>.
- `rootDir?{:ts}` : A directory to execute `git`.
When `dependent` or an element of `dependencies`, or `tsConfig` is given as a relative path,
`rootDir{:ts}` is joined to transform it to an absolute path.
<small>(default: [`core.getConfigDirname(){:ts}`](./haetae-core#getconfigdirname))</small>
- `additionalGraph?{:ts}` : A graph to manually specify explicit dependency relationships.
This is purely additional, not an override or replacement of the source code dependency graph.
<small>(default: <TokenLinkCode inline tokens={{'graph' : './haetae-utils#graph'}}>`graph({ edges: [], rootDir }){:ts}`</TokenLinkCode>)</small>

#### Basic Usage

Let's say,

- ***a.ts*** depends on ***b.ts***.
- ***c.ts*** depends on ***a.ts***, which depends on ***b.ts***
- ***e.ts*** does not (even transitively) depend on neither ***f.ts*** nor ***b.ts***.
- ***f.ts*** does not (even transitively) depend on ***b.ts***.

then the result would be like this.

```ts
const dependencies = ['f.ts', 'b.ts']

dependsOn({ dependent: 'a.ts', dependencies }) // true
dependsOn({ dependent: 'c.ts', dependencies }) // true -> transitively
dependsOn({ dependent: 'e.ts', dependencies }) // false
dependsOn({ dependent: 'f.ts', dependencies }) // true -> 'f.ts' depends on 'f.ts' itself.
```

#### Usage With `git.changedFiles`

It is a good practice to use with [`git.changedFiles`](./haetae-git#changedfiles) of `@haetae/git{:ts}`.

<TokenLinkCode tokens={{
  '.configure': './haetae-core#configure',
  '.glob': './haetae-utils#glob',
  '$': './haetae-utils#dollar',
  '.changedFiles': './haetae-git#changedfiles',
}}>
```js filename="haetae.config.js"
import { $, core, utils, git, js } from 'haetae'

export default core.configure({
  // Other options are omitted for brevity
  commands: {
    myTest: {
      env: { /* ... */ },
      run: async () => {
        const changedFiles = await git.changedFiles()
        const testFiles = await utils.glob(['**/*.test.js'])
        // An array of test files which (transitively) depend on changed files
        const affectedTestFiles = testFiles.filter((testFile) =>
          js.dependsOn({
            dependent: testFile,
            dependencies: changedFiles,
          }),
        )

        if (affectedTestFiles.length > 0) {
          // Equals to "pnpm jest /path/to/foo.test.ts /path/to/bar.test.ts ..."
          // Change 'pnpm' and 'jest' to your package manager and test runner.
          await $`pnpm jest ${affectedTestFiles.join(' ')}`
      },
    },
  },
})
```
</TokenLinkCode>

#### Usage With `additionalGraph`

Sometimes, automatic dependency resolution is not enough.<br/>
It can find relationships only between source code files, like **.js**, **.jsx**, **.ts** or **.tsx**.<br/>
You can specify additional dependency relationships manually.<br/>
Then `dependsOn` would still automatically resolve the dependencies, but also check the given `additionalGraph`.

<TokenLinkCode tokens={{
  '.graph': './haetae-utils#graph',
  '.glob': './haetae-utils#glob',
}}>
```js
import { utils, js } from 'haetae'

const additionalGraph = utils.graph({
  edges: [
    {
      dependents: await utils.glob(['**/*.test.{ts,js}']),
      dependencies:['.env.test', '.env.development'],
    },
    {
      dependents: await utils.glob([
        'tests/integration/**/*.test.ts',
        'tests/e2e/**/*.test.tsx',
      ]),
      dependencies: ['data-for-test.sql'],
    },
  ],
})

// Other contexts are ommitted for brevity.
// Refer to the previous example snippet.
js.dependsOn({
  dependent: file,
  dependencies: changedFiles,
  additionalGraph, // <= Added
})
```
</TokenLinkCode>
