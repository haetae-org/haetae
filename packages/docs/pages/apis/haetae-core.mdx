import { Callout } from 'nextra-theme-docs'
import PkgManagerTabs from '../../components/PkgManagerTabs'
import Chip from '../../components/Chip'
import TokenLinkCode from '../../components/TokenLinkCode'

export const Memoized = () => (<Chip label='Memoized' href='./introduction#memoization' />)
export const PathPrinciples = () => (<Chip label='Path Principles' href='./introduction/#path-principles' />)

# `@haetae/core`

`@haetae/core{:ts}` provides every core feature for Haetae.<br/>
For instance, it handles config file, store file, and your command's `env` and `run`.<br/>
If you want to use Haetae by programatic api, you probably need this package.

## Dependents

- [`@haetae/utils{:ts}`](./haetae-utils)
- [`@haetae/javascript{:ts}`](./haetae-javascript)
- [`@haetae/git{:ts}`](./haetae-git)
- [`@haetae/cli{:ts}`](./haetae-cli)
- [`haetae{:ts}`](./haetae)

## Installation

Unlike other `@haetae/*{:ts}` packages, `@haetae/core{:ts}` doesn't have `peerDependencies`.
Just purely installing `@haetae/core{:ts}` itself is enough.

<Callout>
  **Are you developing a library(e.g. plugin) for Haetae?** <br />
  It might be more suitable to specify `@haetae/core{:ts}` as `peerDependencies` than `dependencies`.
</Callout>

<br/>

<PkgManagerTabs>
```bash
# As dependencies
npm install @haetae/core
# As devDependencies
npm install --save-dev @haetae/core
```
```bash
# As dependencies
yarn add @haetae/core
# As devDependencies
yarn add --dev @haetae/core
```
```bash
# As dependencies
pnpm add @haetae/core
# As devDependencies
pnpm add --save-dev @haetae/core
```
</PkgManagerTabs>

## API

### `pkg`

Refer to [introduction#pkg](./introduction#pkg).

### `SetCurrentCommandOptions`

An argument interface of function [`setCurrentCommand`](#setcurrentcommand).

```ts
interface SetCurrentCommandOptions {
  command: string
}
```

### `setCurrentCommand`

A setter for current command name, which is a module-level state.<br/>
Set it before calling other APIs that require it (as a default parameter).

**Type**

```ts
(options: SetCurrentCommandOptions) => void
```

**Options?**

- `command{:ts}` : A name of command to run for current execution.

### `getCurrentCommand`

A getter for current command name, which is a module-level state.

**Type**

```ts
() => string
```

### `defaultConfigFiles`

An array of string constant for default config file name.<br/>
This is used when config file path is not given or given as a directory.

**Type**

```ts
[
  'haetae.config.js',
  'haetae.config.mjs',
  'haetae.config.ts',
  'haetae.config.mts',
]
```

### `SetConfigFilenameOptions`

An argument interface of function [`setConfigFilename`](#setconfigfilename).
```ts
interface SetConfigFilenameOptions {
  filename?: string
  cwd?: string
  checkExistence?: boolean
}
```

### `setConfigFilename`

A setter for config file name, which is a module-level state.<br/>
Set it before calling other APIs that requires a config file.

**Type**

<TokenLinkCode tokens={['SetConfigFilenameOptions']}>
```ts
(options?: SetConfigFilenameOptions) => void
```
</TokenLinkCode>

**Options?**

- `filename?{:ts}` : A config file path.
- `cwd?{:ts}` : A directory to join or start search from. <small>(default: [`process.cwd(){:ts}`](https://nodejs.org/api/process.html#processcwd))</small>
- `checkExistence?{:ts}`: Whether to check if `filename` exists. No effect when `filename` is not given. <small>(default: `true{:ts}`)</small>

#### When `filename` is given

`filename` can be either an absolute or relative path.
If relative, `filename` will be joined with `cwd{:ts}`.<br/>
If `filename` does not exist on the filesystem, it throws an error when `checkExistence` is `true{:ts}`.

#### When `filename` is not given

It will try finding the config file (one of [`defaultConfigFiles`](#defaultconfigfiles))
by walking up parent directories recursively, starting from `cwd`.<br/>
- If not found, it throws an error.<br/>
- If multiple files (of [`defaultConfigFiles`](#defaultconfigfiles)) exist,
  - A file closer to `cwd` is chosen.
  - If distances from `cwd` are same, priority order is same as [`defaultConfigFiles`](#defaultconfigfiles).

### `getConfigFilename`
<br/>
<PathPrinciples/>

A getter for config file name, which is a module-level state.

**Type**

```ts
() => string
```

### `getConfigDirname`
<br/>
<PathPrinciples/>

A getter for config file's directory name, which is a derived module-level state.<br/>
Throws an error if the config file is not yet set.

**Type**

```ts
() => string
```

### `defaultStoreFile`

A string constant for default store file name.<br/>
This is used when store file is not given, or given as a directory.

**Type**

```ts
'.haetae/store.json'
```

### `SetStoreFilenameOptions`

An argument interface of function [`setStoreFilename`](#setstorefilename).

```ts
interface SetStoreFilenameOptions {
  filename: string
  rootDir?: string
}
```

### `setStoreFilename`

A setter for store file name, which is a module-level state.<br/>
Set the store filename by this setter function, before calling other APIs that require store filename.

<Callout>
**Priority against config**<br/>
Calling this function overrides config file's `storeFile` option.<br/>
But it does not change the content of the config file (e.g. haetae.config.js) or modify the [memoized](./introduction#memoization) (by [getConfig](#getconfig)) config object in memory.
</Callout>

**Type**

<TokenLinkCode tokens={['SetStoreFilenameOptions']}>
```ts
(options: SetStoreFilenameOptions) => void
```
</TokenLinkCode>

**Options**

- `filename{:ts}` : A store file path. If it does not end with `'.json'{:ts}`, `'store.json'{:ts}` is appended internally. <small>(e.g. `'/path/to'{:ts}` becomes `'/path/to/store.json'{:ts}`)</small>
- `rootDir?{:ts}` : A directory to join with `filename{:ts}` when `filename{:ts}` is a relative path.
 <small>(default: [`getConfigDirname(){:ts}`](#getconfigdirname))</small>

### `getStoreFilename`

A getter for store file name, which is a module-level state.<br/>

**Type**

```ts
() => string
```

### `HaetaeRecord`

```ts
interface HaetaeRecord<D extends Rec = Rec, E extends Rec = Rec>  {
  data: D
  env: E
  time: number
}
```

### `HaetaeStore`

<TokenLinkCode tokens={['HaetaeRecord']}>
```ts
interface HaetaeStore<D extends Rec = Rec, E extends Rec = Rec> {
  version: string
  commands: {
    [command: string]: HaetaeRecord<D, E>[]
  }
}
```
</TokenLinkCode>

### `HaetaeCommandEnv`

```ts
<E extends Rec>() => void | PromiseOr<E>
```

### `HaetaePreCommandEnv`

<TokenLinkCode tokens={['HaetaeCommandEnv']}>
```ts
type HaetaePreCommandEnv<E extends Rec> =
  | HaetaeCommandEnv<E>
  | PromiseOr<E | undefined>
```
</TokenLinkCode>

### `HaetaeCommandRun`

```ts
<D extends Rec>() => void | PromiseOr<D | undefined>
```

### `HaetaePreCommand`

<TokenLinkCode tokens={['HaetaeCommandRun', 'HaetaePreCommandEnv']}>
```ts
interface HaetaePreCommand<D extends Rec, E extends Rec> {
  run: HaetaeCommandRun<D>
  env?: HaetaePreCommandEnv<E>
}
```
</TokenLinkCode>

### `HaetaeCommand`

<TokenLinkCode tokens={['HaetaeCommandRun', 'HaetaeCommandEnv']}>
```ts
interface HaetaeCommand<D extends Rec, E extends Rec> {
  run: HaetaeCommandRun<D>
  env: HaetaeCommandEnv<E>
}
```
</TokenLinkCode>

### `RootEnv`

```ts
<E extends Rec>(envFromCommand: E) => PromiseOr<E>
```

### `RootRecordData`

```ts
<A extends Rec, R extends Rec = A>(recordDataFromCommand: A) => PromiseOr<R>
```

### `HaetaePreConfig`

An interface of user-given config schema.<br/>
Also an argument interface of function [`configure`](#configure).

<TokenLinkCode tokens={['HaetaePreCommand', 'RootEnv', 'RootRecordData']}>
```ts
export interface HaetaePreConfig {
  commands: {
    [command: string]: HaetaePreCommand<Rec, Rec>
  }
  env?: RootEnv<Rec>
  recordData?: RootRecordData<Rec>
  recordRemoval?: {
    age?: string | number
    count?: number
  }
  storeFile?: string
}
```
</TokenLinkCode>

### `HaetaeConfig`

An interface of normalized config schema.<br/>
Also a return type of function [`configure`](#configure).

<TokenLinkCode tokens={['HaetaeCommand', 'RootEnv', 'RootRecordData']}>
```ts
interface HaetaeConfig<D extends Rec, E extends Rec> {
  commands: {
    [command: string]: HaetaeCommand<D, E>
  }
  env: RootEnv<E>
  recordData: RootRecordData<D>
  recordRemoval: {
    age: number
    count: number
  }
  storeFile: string
}
```
</TokenLinkCode>

### `configure`
<br/>
<PathPrinciples/>

`configure` validates and transform the user-provided config(e.g. `haetae.config.js`) into normalized config.

<Callout>
**`haetae`'s `configure` vs `@haetae/core`'s `configure`**<br/>
They are different. Refer to docs of `haetae`'s [`configure`](./haetae#configure) for the difference.
</Callout>

<Callout>
**Idempotent function**<br/>
`configure(obj){:ts}` is eqaul to `configure(configure(obj)){:ts}`.<br/>
<small>(The only exception is when [`setStoreFilename{:ts}`](#setstorefilename) is called with different arguments
between each call of `configure`, which is unlikey to happen in real world scenario.)</small>
</Callout>

**Type**

<TokenLinkCode tokens={['HaetaePreConfig', 'HaetaeConfig']}>
```ts
<D extends Rec, E extends Rec>(options: HaetaePreConfig) => HaetaeConfig<D, E>
```
</TokenLinkCode>

**Options**

- `commands{:ts}` : Your commands as an object.
- `env?{:ts}` : An env-to-env mapper/transformer. <small>(default: `(arg) => arg{:ts}`)</small>
- `recordData?{:ts}` : An recordData-to-recordData mapper/transformer. <small>(default: `(arg) => arg{:ts}`)</small>
- `recordRemoval.age?{:ts}` : Age threshold by milliseconds.
Records whose age are older than this value are to be removed when calling [`addRecord`](#addrecord).
<small>(default: `Number.POSITIVE_INFINITY{:ts}`)</small>
- `recordRemoval.count?{:ts}` : The number of total records to keep.
When the number of records becomes larger than this value, old records are removed to satisfy the threshold
when calling [`addRecord`](#addrecord). This task is executed after that of `recordRemoval.age`.
<small>(default: `Number.POSITIVE_INFINITY{:ts}`) </small>
- `storeFile?{:ts}` : A store file path. Internally, it is used to [`setStoreFilename({ filename: storeFile }){:ts}`](#setstorefilename)
only if `setStoreFilename` is never called before. If `setStoreFilename` is called before calling `configure`,
the option `storeFile` does not have any effect, even to the result `HaetaeConfig` object.
<small>(default: [`defaultStoreFile{:ts}`](#defaultstorefile))</small>

#### Type-check for your config

The below example is 100% valid. <br/>
The exported raw json will be processed by `configure` internally.<br/>
But you'd not get type-check from the IDE.

```js filename="haetae.config.js"
export default { /* ... */ }
```

With `configure`, type-check is enabled. Your IDE is Happy! 😊

```js filename="haetae.config.js"
import { core } from 'haetae'
// Or `import * as core from '@haetae/core'`

export default core.configure({ /* ... */ })
```

#### Normalization

Schema of [`HaetaeConfig`](#haetaeconfig) (return type) is ***roughly*** similar to that of [`HaetaePreConfig`](#haetaepreconfig) (argument type).
The return value is a normalized result of user-given (argument) config.
Omitted options from user-given config(`HaetaePreConfig`) are to be set as their default values in `HaetaeConfig`.
Given value of `storeFile` is replaced by a return value of [`getStoreFilename(){:ts}`](#getstorefilename).

### `GetConfigOptions`

An argument interface of function [`getConfig`](#getconfig) and [`deleteStore`](#deletestore).

```ts
interface GetConfigOptions {
  filename?: string
}
```

### `getConfig`
<br/>
<Memoized/>

A function to get config object by config file path.

**Type**

<TokenLinkCode tokens={['GetConfigOptions', 'HaetaeConfig']}>
```ts
<D extends Rec, E extends Rec>(options?: GetConfigOptions) => Promise<HaetaeConfig<D, E>>
```
</TokenLinkCode>

**Options?**

- `filename?{:ts}` : A path to config file.
If given as a relative path, [`process.cwd(){:ts}`](https://nodejs.org/api/process.html#processcwd) is joined in front of it.
If given as an absolute path, it's used as-is.
<small>(default: [`getConfigFilename(){:ts}`](#getconfigfilename))</small>

### `initNewStore`

Initializes an empty store. It just returns an object. It does not save it as a file.

**Type**

<TokenLinkCode tokens={['HaetaeStore']}>
```ts
<D extends Rec, E extends Rec>() => HaetaeStore<D, E>
```
</TokenLinkCode>

### `GetStoreOptions`

An argument interface of function [`getStore`](#getstore).

<TokenLinkCode tokens={['HaetaeStore']}>
```ts
interface GetStoreOptions<D extends Rec, E extends Rec> {
  filename?: string
  fallback?: ({
    filename,
    error,
  }: {
    filename: string
    error: Error
  }) => PromiseOr<HaetaeStore<D, E>> | never
}
```
</TokenLinkCode>

### `getStore`
<br/>
<Memoized/>

**Type**

<TokenLinkCode tokens={['GetStoreOptions', 'HaetaeStore']}>
```ts
<D extends Rec, E extends Rec>(options?: GetStoreOptions<D, E>) => Promise<HaetaeStore<D, E>>
```
</TokenLinkCode>

A function to get store object.

**Options?**

- `filename?{:ts}` : A path to store file (e.g. `'/path/to/.haetae/store.json'{:ts}`). <small>(default: [`getStoreFilename(){:ts}`](#getstorefilename))</small>
- `fallback?{:ts}` : A function to generate an alternative return value, when `filename` is a non-existent file. `fallback` can be useful if you want to throw an error (e.g. `({error}) => { throw error }{:ts}`) rather than get a new store object from [`initNewStore`](#initnewstore) by default. <small>(default: [`initNewStore(){:ts}`](`#initnewstore))</small>

### `GetRecordsOptions`

An argument interface of function [`getRecords`](#getrecords).

<Callout>
There're [`GetRecordsOptions`](#getrecordsoptions) (plural) and [`GetRecordOptions`](#getrecordoptions) (singular). Don't confuse!
</Callout>

<TokenLinkCode tokens={['HaetaeStore']}>
```ts
interface GetRecordsOptions<D extends Rec, E extends Rec> {
  command?: PromiseOr<string>
  store?: PromiseOr<HaetaeStore<D, E>>
}
```
</TokenLinkCode>

### `getRecords`

A function to get records of a given command from given store.

<Callout>
There're [`getRecords`](#getrecords) (plural) and [`getRecord`](#getrecord) (singular). Don't confuse!
</Callout>

**Type**

<TokenLinkCode tokens={['GetRecordsOptions', 'HaetaeRecord']}>
```ts
<D extends Rec = Rec, E extends Rec = Rec>(options?: GetRecordsOptions<D, E>) => Promise<HaetaeRecord<D, E>[] | undefined>
```
</TokenLinkCode>

**Options?**

- `command?{:ts}` : A command name to get records of. <small>(default: [`getCurrentCommand(){:ts}`](#getcurrentcommand))</small>
- `store?{:ts}` : A store object. <small>(default: [`getStore(){:ts}`](`getstore()`))</small>

### `CommandFromConfig`

An argument interface of function [`invokeEnv`](#invokeenv) and [`invokeRun`](#invokerun).

<TokenLinkCode tokens={['HaetaeConfig']}>
```ts
interface CommandFromConfig<D extends Rec, E extends Rec> {
  command?: PromiseOr<string>
  config?: PromiseOr<HaetaeConfig<D, E>>
}
```
</TokenLinkCode>

### `invokeEnv`
<br/>
<Memoized/>

A function to invoke(execute) user-defined `env` of the given `command`.

**Type**

<TokenLinkCode tokens={['CommandFromConfig']}>
```ts
<E extends Rec>(options?: CommandFromConfig<Rec, E>) => Promise<E>
```
</TokenLinkCode>

**Options?**

- `command?{:ts}` : A command name to invoke `env` of. <small>(default: [`getCurrentCommand(){:ts}`](#getcurrentcommand))</small>
- `config?{:ts}` : A config object. <small>(default: [`getConfig(){:ts}`](#getconfig))</small>

### `invokeRun`

A function to invoke (execute) user-defined `run` of the given `command`.

**Type**

<TokenLinkCode tokens={['CommandFromConfig']}>
```ts
<D extends Rec>(options?: CommandFromConfig<D, Rec>) => Promise<D>
```
</TokenLinkCode>

**Options?**

- `command?{:ts}` : A command name to invoke `env` of. <small>(default: [`getCurrentCommand(){:ts}`](#getcurrentcommand))</small>
- `config?{:ts}` : A config object. <small>(default: [`getConfig(){:ts}`](#getconfig))</small>

### `compareEnvs`

A function to compare two resolved env object.<br/>
Returns `true{:ts}` if they're equal, `false{:ts}` otherwise.

**Type**

```ts
(one: Rec, theOther: Rec) => boolean
```

**Arguments**

- `one` : A resolved env object to compare with `theOther`.
- `theOther` : A resolved env object to compare with `one`.

### `GetRecordOptions`

An argument interface of a function `getRecord`.

<Callout>
There're [`GetRecordsOptions`](#getrecordsoptions) (plural) and [`GetRecordOptions`](#getrecordoptions) (singular). Don't confuse!
</Callout>

<TokenLinkCode tokens={['GetRecordsOptions']}>
```ts
interface GetRecordOptions<D extends Rec, E extends Rec>
  extends GetRecordsOptions<D, E> {
  env?: PromiseOr<E>
}
```
</TokenLinkCode>

### `getRecord`

A function to get a record of a given command from given store, corresponding to the given env.

<Callout>
There're [`getRecords`](#getrecords) (plural) and [`getRecord`](#getrecord) (singular). Don't confuse!
</Callout>

**Type**

<TokenLinkCode tokens={['GetRecordOptions', 'HaetaeRecord']}>
```ts
<D extends Rec = Rec, E extends Rec = Rec>(options?: GetRecordOptions<D, E>) => Promise<HaetaeRecord<D, E> | undefined>
```
</TokenLinkCode>

**Options?**

- `command?{:ts}` : A command name to get records of. <small>(default: [`getCurrentCommand(){:ts}`](#getcurrentcommand))</small>
- `store?{:ts}` : A store object. <small>(default: [`getStore(){:ts}`](#getstore))</small>
- `env?{:ts}` : A resolved env object. <small>(default: [`invokeEnv({ command }){:ts}`](#invokeenv))</small>

### `FormRecordOptions`

An argument interface of function [`formRecord`](#formrecord).

```ts
interface FormRecordOptions<D extends Rec, E extends Rec> {
  data?: PromiseOr<D>
  env?: PromiseOr<E>
  time?: number
}
```

### `formRecord`

A function to create a new record object.<br/>
This only returns an object, not save it.

**Type**

<TokenLinkCode tokens={['FormRecordOptions', 'HaetaeRecord']}>
```ts
<D extends Rec, E extends Rec>(options?: FormRecordOptions<D, E>) => Promise<HaetaeRecord<D, E>>
```
</TokenLinkCode>

**Options?**

- `data?{:ts}` : A record data. <small>(default: [`invokeRun(){:ts}`](#invokerun))</small>
- `env?{:ts}` : A resolved env object. <small>(default: [`invokeEnv(){:ts}`](#invokeenv)</small>
- `time?{:ts}` : [Unix timestamp](https://en.wikipedia.org/wiki/Unix_time) by milliseconds. <small>(default: [`Date.now(){:ts}`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/now))</small>

### `AddRecordOptions`

An argument interface of function [`addRecord`](#addrecord).

<TokenLinkCode tokens={['HaetaeConfig', 'HaetaeStore', 'HaetaeRecord']}>
```ts
interface AddRecordOptions<D extends Rec, E extends Rec> {
  config?: PromiseOr<HaetaeConfig<D, E>>
  command?: PromiseOr<string>
  store?: PromiseOr<HaetaeStore<D, E>>
  record?: PromiseOr<HaetaeRecord<D, E>>
}
```
</TokenLinkCode>

### `addRecord`

A function to add a new record under the given command to store.

**Type**

<TokenLinkCode tokens={['AddRecordOptions', 'HaetaeStore']}>
```ts
<D extends Rec, E extends Rec>(options?: AddRecordOptions<D, E>) => Promise<HaetaeStore<D, E>>
```
</TokenLinkCode>

**Options?**

- `config?{:ts}` : A config object. <small>(default: [`getConfig(){:ts}`](#getconfig))</small>
  - `config.recordRemoval.age{:ts}`: Age threshold by milliseconds. Records whose age are older than this value are removed.
  - `config.recordRemoval.count{:ts}`: The number of total records to keep. When the number of records becomes larger than this value, old records are removed to satisfy the threshold. This task is executed after that of `config.recordRemoval.age{:ts}`.
- `command?{:ts}` : A command name to add record under. <small>(default: [`getCurrentCommand(){:ts}`](#getcurrentcommand))</small>
- `store?{:ts}` : A store object. <small>(default: [`getStore(){:ts}`](#getstore))</small>
- `record?{:ts}` : A new record object to add. <small>(default: <TokenLinkCode tokens={['formRecord', 'invokeRun', 'invokeEnv']}>`formRecord({ data: invokeRun({ command }), env: invokeEnv({ command }) }){:ts}`</TokenLinkCode>)</small>

### `SaveStoreOptions`

An argument interface of function [`saveStore`](#savestore).

<TokenLinkCode tokens={['HaetaeStore']}>
```ts
interface SaveStoreOptions {
  filename?: string
  store?: PromiseOr<HaetaeStore>
}
```
</TokenLinkCode>

### `saveStore`

A function to save store object to file.<br/>
Memoization cache of [`getStore`](#getstore) would be clear automatically.<br/>
File IO and Memoization cache clear is done sequentially in synchronous manner, as a transaction.

**Type**

<TokenLinkCode tokens={['SaveStoreOptions']}>
```ts
(options?: SaveStoreOptions) => Promise<void>
```
</TokenLinkCode>

**Options?**

- `filename?{:ts}` : A file path to write store on. <small>(default: [`getStoreFilename(){:ts}`](#getstorefilename))</small>
- `store?{:ts}` : A store object to save. <small>(default: [`addRecord(){:ts}`](#addrecord))</small>

### `DeleteStoreOptions`

An argument interface of function [`deleteStore`](#deleteStore).

```ts
interface DeleteStoreOptions {
  filename?: string
}
```

### `deleteStore`

A function to delete the entire store by removing the store file.<br/>
Memoization cache of [`getStore`](#getstore) would be clear automatically.<br/>
File IO and Memoization cache clear is done sequentially in synchronous manner, as a transaction.

**Type**

<TokenLinkCode tokens={['DeleteStoreOptions']}>
```ts
(options?: DeleteStoreOptions) => Promise<void>
```
</TokenLinkCode>

**Options?**

- `filename?{:ts}` : A store file path to delete. <small>(default: [`getStoreFilename(){:ts}`](#getstorefilename))</small>
