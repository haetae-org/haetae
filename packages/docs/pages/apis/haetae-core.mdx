import { Callout } from 'nextra-theme-docs'
import PkgManagerTabs from '../../components/PkgManagerTabs'
import Chip from '../../components/Chip'
import TokenLinkCode from '../../components/TokenLinkCode'

export const Memoized = () => (<Chip label='Memoized' href='./introduction#memoization' />)
export const PathPrinciples = () => (<Chip label='Path Principles' href='./introduction/#path-principles' />)

# `@haetae/core`

`@haetae/core{:ts}` provides every core feature for Haetae.<br/>
For instance, it handles the config file, your command's `env` and `run`, etc.<br/>
If you want to use Haetae by programmatic API, you probably need this package.

## Dependents

- [`@haetae/utils{:ts}`](./haetae-utils)
- [`@haetae/javascript{:ts}`](./haetae-javascript)
- [`@haetae/git{:ts}`](./haetae-git)
- [`@haetae/cli{:ts}`](./haetae-cli)
- [`haetae{:ts}`](./haetae)

## Installation

Unlike other `@haetae/*{:ts}` packages, `@haetae/core{:ts}` doesn't have `peerDependencies`.
Just purely installing `@haetae/core{:ts}` itself is enough.

<Callout>
  **Are you developing a library(e.g. plugin) for Haetae?** <br />
  It might be more suitable to specify `@haetae/core{:ts}` as `peerDependencies` than `dependencies`.
</Callout>

<br/>

<PkgManagerTabs>
```bash
# As dependencies
npm install @haetae/core
# As devDependencies
npm install --save-dev @haetae/core
```
```bash
# As dependencies
yarn add @haetae/core
# As devDependencies
yarn add --dev @haetae/core
```
```bash
# As dependencies
pnpm add @haetae/core
# As devDependencies
pnpm add --save-dev @haetae/core
```
</PkgManagerTabs>

## API

### `pkg`

Refer to [introduction#pkg](./introduction#pkg).

### `SetCurrentCommandOptions`

An argument interface of the function [`setCurrentCommand`](#setcurrentcommand).

```ts
interface SetCurrentCommandOptions {
  command: string
}
```

### `setCurrentCommand`

A setter for the current command name, which is a module-level state.<br/>
Set it before calling other APIs that require it (as a default parameter).

**Type**

```ts
(options: SetCurrentCommandOptions) => void
```

**Options?**

- `command{:ts}` : A name of the command to run for current execution.

### `getCurrentCommand`

A getter for the current command name, which is a module-level state.

**Type**

```ts
() => string
```

### `defaultConfigFiles`

An array of string constants for default config file name.<br/>
This is used when the config file path is not given or given as a directory.

**Type**

```ts
[
  'haetae.config.js',
  'haetae.config.mjs',
  'haetae.config.ts',
  'haetae.config.mts',
]
```

### `SetConfigFilenameOptions`

An argument interface of the function [`setConfigFilename`](#setconfigfilename).

```ts
interface SetConfigFilenameOptions {
  filename?: string
  cwd?: string
  checkExistence?: boolean
}
```

### `setConfigFilename`

A setter for the config file name, which is a module-level state.<br/>
Set it before calling other APIs that require a config file.

**Type**

<TokenLinkCode tokens={['SetConfigFilenameOptions']}>
```ts
(options?: SetConfigFilenameOptions) => Promise<void>
```
</TokenLinkCode>

**Options?**

- `filename?{:ts}` : A config file path.
- `cwd?{:ts}` : A directory to join or start the search from.
<small>(default: [`process.cwd(){:ts}`](https://nodejs.org/api/process.html#processcwd))</small>
- `checkExistence?{:ts}`: Whether to check if `filename` exists. No effect when `filename` is not given.
<small>(default: `true{:ts}`)</small>

#### When `filename` is given

`filename` can be either an absolute or relative path.
If relative, `filename` will be joined with `cwd{:ts}`.<br/>
If `filename` does not exist on the filesystem, it throws an error when `checkExistence` is `true{:ts}`.

#### When `filename` is not given

It will try finding the config file (one of [`defaultConfigFiles`](#defaultconfigfiles))
by walking up parent directories recursively, starting from `cwd`.<br/>
- If not found, it throws an error.<br/>
- If multiple files (of [`defaultConfigFiles`](#defaultconfigfiles)) exist,
  - A file closer to `cwd` is chosen.
  - If distances from `cwd` are equal, the priority order is the same as [`defaultConfigFiles`](#defaultconfigfiles).

### `getConfigFilename`
<br/>
<PathPrinciples/>

A getter for the config file name, which is a module-level state.

**Type**

```ts
() => string
```

### `getConfigDirname`
<br/>
<PathPrinciples/>

A getter for the config file's directory name, which is a derived module-level state.<br/>
Throws an error if the config file is not yet set.

**Type**

```ts
() => string
```

### `HaetaeRecord`

```ts
interface HaetaeRecord<D extends Rec = Rec, E extends Rec = Rec>  {
  data: D
  env: E
  time: number
}
```

### `HaetaeCommandEnv`

```ts
<E extends Rec>() => void | PromiseOr<E>
```

### `HaetaePreCommandEnv`

<TokenLinkCode tokens={['HaetaeCommandEnv']}>
```ts
type HaetaePreCommandEnv<E extends Rec> =
  | HaetaeCommandEnv<E>
  | PromiseOr<E | void>
```
</TokenLinkCode>

### `HaetaeCommandRun`

```ts
<D extends Rec>() => void | PromiseOr<D | void>
```

### `HaetaePreCommand`

<TokenLinkCode tokens={['HaetaeCommandRun', 'HaetaePreCommandEnv']}>
```ts
interface HaetaePreCommand<D extends Rec, E extends Rec> {
  run: HaetaeCommandRun<D>
  env?: HaetaePreCommandEnv<E>
}
```
</TokenLinkCode>

### `HaetaeCommand`

<TokenLinkCode tokens={['HaetaeCommandRun', 'HaetaeCommandEnv']}>
```ts
interface HaetaeCommand<D extends Rec, E extends Rec> {
  run: HaetaeCommandRun<D>
  env: HaetaeCommandEnv<E>
}
```
</TokenLinkCode>

### `RootEnv`

```ts
<E extends Rec>(envFromCommand: E) => PromiseOr<E>
```

### `RootRecordData`

```ts
<A extends Rec, R extends Rec = A>(recordDataFromCommand: A) => PromiseOr<R>
```

### `HaetaePreConfig`

An interface of user-given config schema.<br/>
Also an argument interface of the function [`configure`](#configure).

<TokenLinkCode tokens={['HaetaePreCommand', 'RootEnv', 'RootRecordData', 'StoreConnector']}>
```ts
interface HaetaePreConfig {
  commands: Record<string, HaetaePreCommand<Rec, Rec>>
  env?: RootEnv<Rec>
  recordData?: RootRecordData<Rec>
  store?: StoreConnector
}
```
</TokenLinkCode>

### `HaetaeConfig`

An interface of normalized config schema.<br/>
Also a return type of function [`configure`](#configure).

<TokenLinkCode tokens={['HaetaeCommand', 'RootEnv', 'RootRecordData']}>
```ts
interface HaetaeConfig<D extends Rec, E extends Rec> {
  commands: Record<string, HaetaeCommand<D, E>>
  env: RootEnv<E>
  recordData: RootRecordData<D>
}
```
</TokenLinkCode>

### `configure`
<br/>
<PathPrinciples/>

`configure` validates and transform the user-provided config(e.g. `haetae.config.js`) into normalized config.

<Callout>
**Idempotent function**<br/>
`configure(obj){:ts}` is eqaul to `configure(configure(obj)){:ts}`.<br/>
</Callout>

**Type**

<TokenLinkCode tokens={['HaetaePreConfig', 'HaetaeConfig']}>
```ts
<D extends Rec, E extends Rec>(options: HaetaePreConfig) => HaetaeConfig<D, E>
```
</TokenLinkCode>

**Options**

- `commands{:ts}` : Your commands as an object.
- `env?{:ts}` : An env-to-env transformer. <small>(default: `(arg) => arg{:ts}`)</small>
- `recordData?{:ts}` : A recordData-to-recordData transformer. <small>(default: `(arg) => arg{:ts}`)</small>
- `store?{:ts}` : A store connector. <small>(default: [`localStore()`](#localstore))</small>

#### Type-check for your config

The below example is 100% valid. <br/>
The exported raw json will be processed by `configure` internally.<br/>
But you'd not get a type-check from the IDE.

```js filename="haetae.config.js"
export default { /* ... */ }
```

With `configure`, type-check is enabled. Your IDE is Happy! ðŸ˜Š

```js filename="haetae.config.js"
import { core } from 'haetae'

export default core.configure({ /* ... */ })
```

#### Normalization

Schema of [`HaetaeConfig`](#haetaeconfig) (return type) is ***roughly*** similar to
that of [`HaetaePreConfig`](#haetaepreconfig) (argument type).
The return value is a normalized result of a user-given (argument) config.
Omitted options from a user-given config [`HaetaePreConfig`](#haetaepreconfig) are to be set
as their default values in [`HaetaeConfig`](#haetaeconfig).

### `GetConfigOptions`

An argument interface of the function [`getConfig`](#getconfig).

```ts
interface GetConfigOptions {
  filename?: string
}
```

### `getConfig`
<br/>
<Memoized/>

A function to get config object by config file path.

**Type**

<TokenLinkCode tokens={['GetConfigOptions', 'HaetaeConfig']}>
```ts
<D extends Rec, E extends Rec>(options?: GetConfigOptions)
  => Promise<HaetaeConfig<D, E>>
```
</TokenLinkCode>

**Options?**

- `filename?{:ts}` : A path to the config file.
If given as a relative path, [`process.cwd(){:ts}`](https://nodejs.org/api/process.html#processcwd) is joined in front of it.
If given as an absolute path, it's used as-is.
<small>(default: [`getConfigFilename(){:ts}`](#getconfigfilename))</small>

### `ReserveRecordDataOptions`

An option interface of the function [`reserveRecordData`](#reserverecorddata).

```ts
interface ReserveRecordDataOptions {
  dryRun?: boolean
}
```

### `reserveRecordData`

A function to reserve *Record Data*.<br/>
This changes module-level state, the *Reserved Record Data*.<br/>
It returns a result of the *Reserved Record Data*.

**Type**

<TokenLinkCode tokens={['ReserveRecordDataOptions']}>
```ts
<D extends Rec>(recordData: Rec, options?: ReserveRecordDataOptions) => D
```
</TokenLinkCode>

**Options?**

- `dryRun?{:ts}` : If `true{:ts}`, the arg `recordData` is not reserved, but a return value is given as if it's applied.
<small>(default: `false{:ts}`)</small>

### `InvokeEnvOptions`

An argument interface of the function [`invokeEnv`](#invokeenv).

<TokenLinkCode tokens={['HaetaeConfig']}>
```ts
interface InvokeEnvOptions<E extends Rec> {
  command?: string
  config?: HaetaeConfig<Rec, E>
  applyRootEnv?: boolean
}
```
</TokenLinkCode>

### `invokeEnv`
<br/>
<Memoized/>

A function to invoke(execute) user-defined `env` of the given `command`.

**Type**

<TokenLinkCode tokens={['CommandFromConfig']}>
```ts
<E extends Rec>(options?: CommandFromConfig<Rec, E>) => Promise<E>
```
</TokenLinkCode>

**Options?**

- `command?{:ts}` : A command name to invoke `env` of. <small>(default: [`getCurrentCommand(){:ts}`](#getcurrentcommand))</small>
- `config?{:ts}` : A config object.
<small>(default: <TokenLinkCode tokens={['getConfig']} inline>`await getConfig(){:ts}`</TokenLinkCode></small>
- `applyRootEnv?{:ts}` : Whether to apply root env. <small>(default: `true{:ts}`)</small>

### `InvokeRunOptions`

An argument interface of the function [`invokeRun`](#invokerun).

<TokenLinkCode tokens={['HaetaeConfig']}>
```ts
interface InvokeRunOptions<D extends Rec> {
  command?: string
  config?: HaetaeConfig<D, Rec>
  applyReservedRecordData?: boolean
  applyRootRecordData?: boolean
}
```
</TokenLinkCode>

### `invokeRun`

A function to invoke (execute) user-defined `run` of the given `command`.

**Type**

<TokenLinkCode tokens={['CommandFromConfig']}>
```ts
<D extends Rec>(options?: CommandFromConfig<D, Rec>) => Promise<D>
```
</TokenLinkCode>

**Options?**

- `command?{:ts}` : A command name to invoke `env` of. <small>(default: [`getCurrentCommand(){:ts}`](#getcurrentcommand))</small>
- `config?{:ts}` : A config object.
<small>(default: <TokenLinkCode tokens={['getConfig']} inline>`await getConfig(){:ts}`</TokenLinkCode></small>
- `applyReservedRecordData?{:ts}` : Whether to apply reserved *Record Data*. <small>(default: `true{:ts}`)</small>
- `applyRootRecordData?{:ts}` : Whether to apply root *Record Data*. <small>(default: `true{:ts}`)</small>

### `compareEnvs`

A function to compare two resolved env object.<br/>
Returns `true{:ts}` if they're equal, `false{:ts}` otherwise.

**Type**

```ts
(one: Rec, theOther: Rec) => boolean
```

**Arguments**

- `one` : A resolved env object to compare with `theOther`.
- `theOther` : A resolved env object to compare with `one`.

### `FormRecordOptions`

An argument interface of the function [`formRecord`](#formrecord).

```ts
interface FormRecordOptions<D extends Rec, E extends Rec> {
  data?: D
  env?: E
  time?: number
}
```

### `formRecord`

A function to create a new record object.<br/>
This only returns an object, not saves it.

**Type**

<TokenLinkCode tokens={['FormRecordOptions', 'HaetaeRecord']}>
```ts
<D extends Rec, E extends Rec>(options?: FormRecordOptions<D, E>)
  => Promise<HaetaeRecord<D, E>>
```
</TokenLinkCode>

**Options?**

- `data?{:ts}` : A *Record Data*.
<small>(default: <TokenLinkCode tokens={['invokeRun']} inline>`await invokeRun(){:ts}`</TokenLinkCode></small>
- `env?{:ts}` : A resolved env object.
<small>(default: <TokenLinkCode tokens={['invokeEnv']} inline>`await invokeEnv(){:ts}`</TokenLinkCode></small>
- `time?{:ts}` : [Unix timestamp](https://en.wikipedia.org/wiki/Unix_time) by milliseconds.
<small>(default: [`Date.now(){:ts}`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/now))</small>

### `AddRecordOptions`

An argument interface of the function [`addRecord`](#addrecord-1).

<TokenLinkCode tokens={['HaetaeRecord']}>
```ts
interface AddRecordOptions<D extends Rec, E extends Rec> {
  command?: string
  record?: HaetaeRecord<D, E>
}
```
</TokenLinkCode>

### `AddRecord`

A type of function [`addRecord`](#addrecord-1).

<TokenLinkCode tokens={['AddRecordOptions', 'HaetaeRecord']}>
```ts
<D extends Rec, E extends Rec>(
  options?: AddRecordOptions<D, E>,
) => PromiseOr<HaetaeRecord<D, E>>
```
</TokenLinkCode>

### `addRecord`

A function to add a new record to the store.<br/>
The record is to be persisted to the store.

**Type**

<TokenLinkCode tokens={['AddRecord']}>
```ts
AddRecord
```
</TokenLinkCode>

**Options?**

- `command?{:ts}` : A command name to add a new record.
<small>(default: [`getCurrentCommand(){:ts}`](#getcurrentcommand))</small>
- `record?{:ts}` : A new record object to add.<br/>
<small>(default: <TokenLinkCode inline tokens={['formRecord', 'invokeRun', 'invokeEnv']}>
`await formRecord({ data: await invokeRun({ command }), env: await invokeEnv({ command }) }){:ts}`
</TokenLinkCode>)</small>

### `GetRecordOptions`

An argument interface of a function [`getRecord`](#getrecord-1).

<TokenLinkCode tokens={['GetRecordsOptions']}>
```ts
interface GetRecordOptions<E extends Rec> {
  command?: string
  env?: E
}
```
</TokenLinkCode>

### `GetRecord`

A type of function [`getRecord`](#getrecord-1).

<TokenLinkCode tokens={['GetRecordsOptions', 'HaetaeRecord']}>
```ts
<D extends Rec = Rec, E extends Rec = Rec>(
  options?: GetRecordOptions<E>,
) => PromiseOr<HaetaeRecord<D, E> | undefined>
```
</TokenLinkCode>

### `getRecord`

A function to get a record of a given command, corresponding to the given env.<br/>
`undefined` is returned when there's no record.

**Type**

<TokenLinkCode tokens={['GetRecord']}>
```ts
GetRecord
```
</TokenLinkCode>

**Options?**

- `command?{:ts}` : A command name to get records of.
<small>(default: [`getCurrentCommand(){:ts}`](#getcurrentcommand))</small>
- `env?{:ts}` : A resolved env object. <small>
(default: <TokenLinkCode tokens={['invokeEnv']} inline>
`await invokeEnv({ command }){:ts}`</TokenLinkCode>)</small>

### `StoreConnector`

An interface of store connector.

<TokenLinkCode tokens={['AddRecord', 'GetRecord']}>
```ts
interface StoreConnector {
  addRecord: AddRecord
  getRecord: GetRecord
}
```
</TokenLinkCode>

### `LocalStoreConnector`

An interface of local store connector.

<TokenLinkCode tokens={[
  'LocalStoreConnectorInitNewStore',
  'LocalStoreConnectorLoadStore',
  'LocalStoreConnectorSaveStore']}>
```ts
interface LocalStoreConnector extends StoreConnector {
  initNewStore<D extends Rec, E extends Rec>(): LocalStore<D, E>
  loadStore<D extends Rec, E extends Rec>(
    options?: LoadStoreOptions,
  ): Promise<LocalStore<D, E>>
  saveStore(store: LocalStore): Promise<void>
  localStore: {
    filename: string
    recordRemoval: {
      age: number
      count: number
    }
  }
}
```
</TokenLinkCode>

### `LocalStoreOptions`

An argument interface of a function [`localStore`](#localStore).

```ts
interface LocalStoreOptions {
  filename?: string
  recordRemoval?: {
    age?: number
    count?: number
  }
}
```

### `localStore`

A function to create a *Store Connector* that reads and writes to a local file.

**Type**

<TokenLinkCode tokens={['LocalStoreOptions', 'LocalStoreConnector']}>
```ts
(options?: LocalStoreOptions): LocalStoreConnector
```
</TokenLinkCode>

**Options?**

- `filename?{:ts}` : The store file.
<small>(default: `core.getConfigDirname() + '/.haetae/store.json'{:ts}`</small>
- `recordRemoval.age?{:ts}` : Age threshold by milliseconds
(e.g. 90 * 24 * 60 * 60 * 1000 => 90days).
Records whose age is older than this value are to be removed when calling [`addRecord`](#addrecord).
<small>(default: `Number.POSITIVE_INFINITY{:ts}`)</small>
- `recordRemoval.count?{:ts}` : The number of total records to keep.
When the number of records becomes larger than this value, old records are removed to satisfy the threshold
when calling [`addRecord`](#addrecord). This task is executed after `recordRemoval.age{:ts}` is used.
<small>(default: `Number.POSITIVE_INFINITY{:ts}`) </small>

### `LocalStoreConnector.initNewStore`

Initializes an empty store. It just returns an object. It does not save it as a file.

**Type**

<TokenLinkCode tokens={['LocalStore']}>
```ts
<D extends Rec, E extends Rec>() => LocalStore<D, E>
```
</TokenLinkCode>

### `LoadStoreOptions`

An argument interface of the function [`LocalStoreConnector.loadStore{:ts}`](#localstoreconnectorloadstore).

```ts
interface LoadStoreOptions {
  initWhenNotFound?: boolean
}
```

### `LocalStore`

An interface for the local store file.

<TokenLinkCode tokens={['HaetaeRecord']}>
```ts
interface LocalStore<D extends Rec = Rec, E extends Rec = Rec> {
  version: string
  commands: {
    [command: string]: HaetaeRecord<D, E>[]
  }
}
```
</TokenLinkCode>

### `LocalStoreConnector.loadStore`
<br/>
<Memoized/>

A function to load a store object from the file.

**Type**

<TokenLinkCode tokens={['LoadStoreOptions', 'LocalStore']}>
```ts
<D extends Rec, E extends Rec>(options?: LoadStoreOptions<D, E>)
  => Promise<LocalStore<D, E>>
```
</TokenLinkCode>

**Options?**

- `initWhenNotFound?{:ts}` : Whether to throw an error or just initialize a new store object
when `filename` does not exist in the filesystem.
If `true{:ts}`, [`LocalStoreConnector.initNewStore(){:ts}`](#localstoreconnectorinitnewstore) is returned,
and the filesystem is not affected.
<small>(default: `true{:ts}`)</small>


### `LocalStoreConnector.saveStore`

A function to save a store object to a file.<br/>
Memoization cache of [`LocalStoreConnector.loadStore{:ts}`](#localstoreconnectorloadstore) would be clear automatically.<br/>

**Type**

<TokenLinkCode tokens={['LocalStore']}>
```ts
(store: LocalStore) => Promise<void>
```
</TokenLinkCode>

**Options?**

- `store?{:ts}` : A store object to save.
<small>(default: <TokenLinkCode tokens={['addRecord']} inline>`await addRecord(){:ts}`</TokenLinkCode>)</small>
